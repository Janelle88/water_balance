---
author: "Janelle Christensen, David Thoma, Mike Tercek, John Gross"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output: "html_document"

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```


```{r}
# ------------
# set variables for the data and code
# all of this should be changed before the code is run for a new site
# ------------
# 
save_images = FALSE # do you want to save individual .png files of all plots generated in the report? if so, change to TRUE
#
# ------------
# uncomment the following section for running the .Rmd for a single site.
# if running a batch based off of run_rmd.R, leave these commented out
# to uncomment all, highlight from site to wet_year and press ctrl + shift + c on windows
# or command + shift + c on a mac
# ------------
#
# site = "Blacktail Ponds"
# 
# lat = 44.96
# 
# lon = -111.6
# 
# model_bc = "MRI-CGCM3" # "best case"
# 
# # model options: CCSM4, inmcm4, NorESM1-M, MRI-CGCM3, MIROC5, IPSL-CM5A-LR,  HadGEM2-CC365, GFDL-ESM2G, CanESM2, CSIRO-Mk3-6-0, CNRM-CM5, BNU-ESM
# 
# model_bc_rcp = "rcp85"
# 
# #options: "rcp45", "rcp85"
# 
# model_wc = "HadGEM2-CC365" # "worst case"
# 
# # model options: CCSM4, inmcm4, NorESM1-M, MRI-CGCM3, MIROC5, IPSL-CM5A-LR,  HadGEM2-CC365, GFDL-ESM2G, CanESM2, CSIRO-Mk3-6-0, CNRM-CM5, BNU-ESM
# 
# model_wc_rcp = "rcp85"
# 
# #options: "rcp45", "rcp85"
# 
# past_data = "gridMET"
# 
# # past_data options: "gridMET", "Daymet"
# # if you want to use data that will work with the future models, gridMET is a better choice. It doesn't require adjusting for any biases
# 
# dry_year = 2012 # a particularly dry year, maybe with lots of fire activity? something for people to reference
# 
# wet_year = 2007 # particulary wet year for people to reference

model_bc_rcp_name = if(model_bc_rcp == "rcp45"){
  paste("RCP 4.5")
} else {
  paste("RCP 8.5")
} #automatically makes a more "readable" version of the rcp for graph titles and such

model_wc_rcp_name = if(model_wc_rcp == "rcp45"){
  paste("RCP 4.5")
} else {
  paste("RCP 8.5")
} #automatically makes a more "readable" version of the rcp for graph titles and such




# -------------
# attach packages
# -------------

if (!require("pacman")) install.packages("pacman")
pacman::p_load(remotes, data.table, here, tidyverse, beepr, lubridate, directlabels, data.table, ggbeeswarm, gghalves, directlabels, ggrepel, splines, magrittr, janitor, ggalt, ggrepel, sp, sf) 
#pacman package installs packages required to run the script
#the p_load function is for the packages that are a part of CRAN

pacman::p_load_gh("earthlab/cft")

library(data.table) 
library(here)
#library(plyr) 
# be careful with this, it causes issues for dplyr::group_by
# I didn't try, but the internet says if you load it before tidyverse, that issue goes away
library(tidyverse)
library(beepr)
library(lubridate)
library(directlabels)
library(data.table)
library(ggbeeswarm)
library(gghalves)
library(directlabels)
library(splines)
library(magrittr)
library(janitor)
library(ggalt)
library(cft)
library(ggrepel)
library(sp)
library(sf)

```

#### Location: (`r round(lat, 3)`, `r round(lon, 3)`)
```{r}

# ---------
# set up function to dynamically change title
# ---------

cap_str <- function(y) {
  c <- strsplit(y, "_")[[1]]
  paste(toupper(substring(c, 1,1)), substring(c, 2),
      sep="", collapse=" ")
}
# function taken from Dr. Arvind Singla 
# https://rstudio-pubs-static.s3.amazonaws.com/408658_512da947714740b99253228f084a08a9.html

title <- sapply(site, cap_str)

```

---
title: "Historical and Projected Water Balance Report for `r title`"
knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(dirname(inputFile), "site.html")) })
---


```{r}

# -----------
# set global options
# -----------

#set theme for all graphs
theme_set(theme_classic() + #has the L shape around the graph
            theme(panel.grid = element_blank(), #removes grid lines
                  plot.title = element_text(size = 25), #title of plot text size
                  legend.text = element_text(size = 15), #legend inside text size
                  legend.title = element_text(size = 18), #legend title text size
                  axis.title.y = element_text(size = 15), #changes y axis lable text size
                  axis.title.x = element_blank(),#x axis text size
                  axis.text.x = element_text(size = 15), #changes x-axis text size
                  axis.text.y = element_text(size = 15), #changes y-axis text size
                  legend.position = "top"))  #location of legend

wrap_sentence <- function(string, width) {
  words <- unlist(strsplit(string, " "))
  fullsentence <- ""
  checklen <- ""
  for(i in 1:length(words)) {
    checklen <- paste(checklen, words[i])
    if(nchar(checklen)>(width+1)) {
      fullsentence <- paste0(fullsentence, "\n")
      checklen <- ""
    }
    fullsentence <- paste(fullsentence, words[i])
  }
  fullsentence <- sub("^\\s", "", fullsentence)
  fullsentence <- gsub("\n ", "\n", fullsentence)
  return(fullsentence)
}
#wrap_sentence function taken from https://stackoverflow.com/a/27734975/14061596


# ----------
# inmcm4, NorESM1-M downloaded wrong, don't use until updated (noted this 8-5-20)
# ----------

```


```{r, include=FALSE}
# Before running the remaining code, create subfolders as needed to save figures, only needs to be run once

#If you don't want to save the figures, then just comment out ggsave inside of the functions.

# create subfolders for figures


here::here(dir.create(paste("sites",
                      site,
                      sep = "/")))

here::here(dir.create(paste("sites",
                            site,
                            "figures",
                            sep = "/")))

here::here(dir.create(paste("sites",
                            site,
                            "figures",
                            paste("lat",lat,"lon",lon,sep = "_"), 
                            sep = "/")))

if(save_images == TRUE){

here::here(dir.create(paste("sites",
                            site,
                            "figures",
                            paste("lat",lat,"lon",lon,sep = "_"),
                            "40_yr_graphs",
                            sep = "/")))

}
```

```{r}
# -------------
# MONTHLY DATA
# clean data for graphing
# if monthly data wasn't downloaded, change {r} to {r, eval = FALSE } or else this will stop your code from running
# -------------

# I added a line of code that removes variables from the data set that sum to 2
# change this if needed

# -------------
# monthly future data
# -------------


future_month_1 <- read_csv(here::here("sites",
                                      site,
                                    "raw_data",
                                    paste("lat",lat,"lon",lon, sep = "_"),
                                    "future_monthly",
                                    paste(site, model_wc, model_wc_rcp, model_bc, model_bc_rcp, "monthly_future.csv", sep = "_")),
                    na = c("-3276.7")) 

date_fm <- future_month_1$date # this is a work around
# want to remove data that has all zeroes conditionally based on lat and lon
# couldn't get data to work to only remove data that had a sum of zero unless removed all non-variable columns

future_month <- future_month_1 %>% 
  select(-lat, -lon, -date) %>% #change this
  select(which(!colSums(., na.rm = TRUE) < 2)) %>% # this removes variable that sum to 2 (i.e. accumswe in a hot climate)
  mutate(date = date_fm,
         year = lubridate::year(date),
         month = lubridate::month(date,
                                  label = TRUE,
                                  abbr = TRUE))

# -------------
# monthly past
# -------------

# -------------
# Daymet cleaning
# -------------


# Daymet downloads date data wrong(all download as 1980), needing the code to be adjusted in the download
# this makes the dates formatted differently, so the data needs to be cleaned differently than gridMET

if(past_data == "Daymet"){ 
  past_month_1 <- read_csv(here::here("sites",
                                      site,
                                  "raw_data",
                                  paste("lat",lat,"lon",lon, sep = "_"),
                                  "historical_monthly",
                                  paste(site,"_monthly_",past_data,".csv",
                                        sep = "")),
                             na = c("-3276.7"))%>%  
    mutate(date = lubridate::ymd(paste(year,
                                     month,
                                     sep = "-"),
                               truncated = 1))#fix this when dates are fixed on site
# when/if dates download correctly for monthly historical, this line can be removed
# truncated needs to be here, can't say why it's 1
  
  date_pm <- past_month_1$date # this is a work around
# want to remove data that has all zeroes conditionally based on lat and lon
# couldn't get data to work to only remove data that had a sum of zero unless removed all non-variable columns

past_month <- past_month_1 %>%
  select(-lat, -lon, -month, - year, -date) %>%
  select(which(!colSums(., na.rm = TRUE) < 2)) %>% # this removes variable that sum to 2 (i.e. accumswe in a hot climate)
  mutate(date = date_pm, #adds date back into the df
         year = lubridate::year(date),
         month = lubridate::month(date,
                                  label = TRUE,
                                  abbr = TRUE))
} 

# ------------
# gridMET cleaning
# ------------

if(past_data == "gridMET"){ 
  past_month_1 <- read_csv(here::here("sites",
                                      site,
                                  "raw_data",
                                  paste("lat",lat,"lon",lon, sep = "_"),
                                  "historical_monthly",
                                  paste(site,"_monthly_",past_data,".csv", sep = "")),
                             na = c("-3276.7"))
  
  date_pm <- past_month_1$date # this is a work around
# want to remove data that has all zeroes conditionally based on lat and lon
# couldn't get data to work to only remove data that had a sum of zero unless removed all non-variable columns

past_month <- past_month_1 %>%
  select(-lat, -lon, -date) %>%
  select(which(!colSums(., na.rm = TRUE) < 2)) %>% # this removes variable that sum to 2 (i.e. accumswe in a hot climate)
  mutate(date = date_pm, #adds date back into the df
         year = lubridate::year(date),
         month = lubridate::month(date,
                                  label = TRUE,
                                  abbr = TRUE))
}


```

```{r}
# ------------
# DAILY DATA
# clean data for graphing
# ------------

# ------------
# daily future data
# ------------

future_day_1 <- read_csv(here::here("sites",
                                    site,
                                  "raw_data",
                                  paste("lat",lat,"lon",lon, sep = "_"),
                                  "future_daily",
                                  paste(site, model_wc, model_wc_rcp, model_bc, model_bc_rcp, "daily_future.csv", sep = "_")),
                    na = c("-3276.7"))

date_fd <- future_day_1$date
# this is a work around
# want to remove data that has all zeroes conditionally based on site
# couldn't get data to work to only remove data that had a sum of zero unless removed all non-variable columns


future_day <- future_day_1 %>% 
  select(-lat, -lon, -date) %>%
  #select(which(!colSums(., na.rm = TRUE) < 2)) %>% # this removes variable that sum to 2 (i.e. accumswe in a hot climate)
  mutate(date = date_fd,
    year = lubridate::year(date), 
    month = lubridate::month(date,
                             label = TRUE,
                             abbr = TRUE),
    day = lubridate::day(date),
    doy = yday(date))


# ------------
# daily past
# ------------

past_day_1 <- read_csv(here::here("sites",
                                      site,
                                  "raw_data",
                                  paste("lat",lat,"lon",lon, sep = "_"),
                                  "historical_daily",
                                  paste(site,"_daily_",past_data,".csv", sep = "")),
                           na = c("-3276.7")) 

date_pd <- past_day_1$date# this is a work around
# want to remove data that has all zeroes conditionally based on lat and lon
# couldn't get data to work to only remove data that had a sum of zero unless removed all non-variable columns

past_day <- past_day_1 %>% 
  select(-lat, -lon, -date)  %>%
  select(which(!colSums(., na.rm = TRUE) < 2)) %>% # this removes variables that sum to 2 (i.e. accumswe in a hot climate)
  mutate(date = date_pd,
         year = lubridate::year(date),
         month = lubridate::month(date,
                                  label = TRUE,
                                  abbr = TRUE),
         day = lubridate::day(date),
         doy = yday(date)) 


```

```{r, eval=FALSE}

# --------------------------------------------------------------------------------------
#
# DATA CLEANING
#
# -------------------------------------------------------------------------------------_


```


```{r}
# -------------
# Make site data into long format
# -------------

# -------------
# past data daily for summarizing by year
# -------------

annual_past <- past_day %>% 
  group_by(year) %>% 
  filter(!year == 2020) %>% 
  summarize(annual_soil_water = mean(soil_water_daily, na.rm = TRUE),
            annual_runoff = sum(runoff_daily, na.rm = TRUE), 
            annual_rain = sum(rain_daily, na.rm = TRUE),
            annual_accumswe = max(accumswe_daily, na.rm = TRUE),
            annual_pet = sum(pet_daily, na.rm = TRUE),
            annual_deficit = sum(deficit_daily, na.rm = TRUE), 
            #annual_agdd = max(agdd_daily, na.rm = TRUE), 
            #put this back in when agdd is working
            annual_aet = sum(aet_daily, na.rm = TRUE))


# -------------
# long format future data daily
# -------------

# -------------
# worst case
# -------------

wc_annual_future <- future_day %>%
  select(soil_water_daily_wc:aet_daily_wc, date:doy) %>% # selecting for variables for 8.5 only
  filter(!year == 2100) %>% 
  group_by(year) %>% 
    summarize(annual_soil_water_wc = mean(soil_water_daily_wc, na.rm = TRUE),
              annual_runoff_wc = sum(runoff_daily_wc, na.rm = TRUE),
              annual_rain_wc = sum(rain_daily_wc, na.rm = TRUE),
              annual_accumswe_wc = max(accumswe_daily_wc, na.rm = TRUE),
              annual_pet_wc = sum(pet_daily_wc, na.rm = TRUE),
              annual_deficit_wc = sum(deficit_daily_wc, na.rm = TRUE),
              #annual_agdd_wc = max(agdd_daily_wc, na.rm = TRUE), 
              #put this back in when agdd is working
              annual_aet_wc = sum(aet_daily_wc, na.rm = TRUE))
    
#-------------
# best case
# ------------
  
bc_annual_future <- future_day %>% 
  select(soil_water_daily_bc:aet_daily_bc, date:doy) %>% #selecting for 4.5 only
  filter(!year == 2100) %>% 
  group_by(year) %>% 
    summarize(annual_soil_water_bc = mean(soil_water_daily_bc, na.rm = TRUE),
              annual_runoff_bc = sum(runoff_daily_bc, na.rm = TRUE),
              annual_rain_bc = sum(rain_daily_bc, na.rm = TRUE),
              annual_accumswe_bc = max(accumswe_daily_bc, na.rm = TRUE),
              annual_deficit_bc = sum(deficit_daily_bc, na.rm = TRUE),
              annual_pet_bc = sum(pet_daily_bc, na.rm = TRUE),
              #annual_agdd_bc = max(agdd_daily_bc, na.rm = TRUE),
              #put this back in when agdd is working
              annual_aet_bc = sum(aet_daily_bc, na.rm = TRUE))

# -----------
# make values into one df
# -----------

# -----------
# best case
# ----------

bc_annual_values <- annual_past %>%
  full_join(bc_annual_future) %>% 
  pivot_longer(`annual_soil_water`:`annual_aet_bc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "annual_value") %>% 
  na.omit(annual_values) %>% # new column name to store values
  mutate(decade = case_when(
    .$year %in% c(1980:1989) ~ "1980s",
    .$year %in% c(1990:1999) ~ "1990s",
    .$year %in% c(2000:2009) ~ "2000s",
    .$year %in% c(2010:2019) ~ "2010s",
    .$year %in% c(2020:2029) ~ "2020s",
    .$year %in% c(2030:2039) ~ "2030s",
    .$year %in% c(2040:2049) ~ "2040s",
    .$year %in% c(2050:2059) ~ "2050s",
    .$year %in% c(2060:2069) ~ "2060s",
    .$year %in% c(2070:2079) ~ "2070s",
    .$year %in% c(2080:2089) ~ "2080s",
    TRUE ~ "2090s"
  ))  %>%  mutate(variable = case_when(
    .$variable %in% c("annual_runoff", "annual_runoff_bc") ~ "Runoff",
    #.Svariable calls the variable, then it can be renamed
    .$variable %in% c("annual_agdd", "annual_agdd_bc") ~ "AGDD",
    .$variable %in% c("annual_soil_water", "annual_soil_water_bc") ~ "Soil Water",
    .$variable %in% c("annual_rain", "annual_rain_bc") ~ "Rain",
    .$variable %in% c("annual_accumswe", "annual_accumswe_bc") ~ "Accumulated SWE",
    .$variable %in% c("annual_pet", "annual_pet_bc") ~ "PET",
    .$variable %in% c("annual_deficit", "annual_deficit_bc") ~ "Deficit",
    TRUE ~ "AET" # last ifelse is just labeled as TRUE
  )) %>% 
  mutate(averages = case_when(
    .$year %in% c(1980:2019) ~ "annual_avg",
    TRUE ~ "annual_avg_bc"
  )) %>% 
  mutate(decades = case_when( #don't need individual decades for this data
    .$year %in% c(1980:2019) ~ "1980-2019",
    .$year %in% c(2020:2059) ~ "2020-2059",
    TRUE ~ "2060-2099")) #decades by 39 yr chunks



# ------------
# worst case
# ------------

wc_annual_values <- annual_past %>% 
  full_join(wc_annual_future) %>%
  pivot_longer(`annual_soil_water`:`annual_aet_wc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "annual_value") %>% 
  na.omit(annual_values) %>% # new column name to store values
  mutate(decade = case_when(
    .$year %in% c(1980:1989) ~ "1980s",
    .$year %in% c(1990:1999) ~ "1990s",
    .$year %in% c(2000:2009) ~ "2000s",
    .$year %in% c(2010:2019) ~ "2010s",
    .$year %in% c(2020:2029) ~ "2020s",
    .$year %in% c(2030:2039) ~ "2030s",
    .$year %in% c(2040:2049) ~ "2040s",
    .$year %in% c(2050:2059) ~ "2050s",
    .$year %in% c(2060:2069) ~ "2060s",
    .$year %in% c(2070:2079) ~ "2070s",
    .$year %in% c(2080:2089) ~ "2080s",
    TRUE ~ "2090s" #decade individually
  )) %>% 
  mutate(variable = case_when( #make names more readable
    .$variable %in% c("annual_runoff", "annual_runoff_wc") ~ "Runoff",
    #.$variable calls the variable, then it can be renamed
    .$variable %in% c("annual_agdd", "annual_agdd_wc") ~ "AGDD",
    .$variable %in% c("annual_soil_water", "annual_soil_water_wc") ~ "Soil Water",
    .$variable %in% c("annual_rain", "annual_rain_wc") ~ "Rain",
    .$variable %in% c("annual_accumswe", "annual_accumswe_wc") ~ "Accumulated SWE",
    .$variable %in% c("annual_pet", "annual_pet_wc") ~ "PET",
    .$variable %in% c("annual_deficit", "annual_deficit_wc") ~ "Deficit",
    TRUE ~ "AET" # last ifelse is just labeled as TRUE
  ))  %>% 
  mutate(averages = case_when(
    .$year %in% c(1980:2019) ~ "annual_avg",
    TRUE ~ "annual_avg_wc"
  )) %>% 
  mutate(decades = case_when( #don't need individual decades for this data
    .$year %in% c(1980:2019) ~ "1980-2019",
    .$year %in% c(2020:2059) ~ "2020-2059",
    TRUE ~ "2060-2099")) #decades by 39 yr chunks

# ---------------
# all together now!
# ---------------

annual_values <- bc_annual_values %>% 
  full_join(wc_annual_values) 


```


```{r, include = FALSE, eval = FALSE}

# ------------
# Histograms and qq plots to look at data spread
# histogram for future data
# ------------

plot_histogram_past = function(.y) {
  .y_hist <- ggplot(data = annual_values %>%
                       filter(decade %in% c(.y))) +
    geom_histogram(aes(x = annual_value), binwidth = 10) +
    facet_wrap(~variable)+
    labs(title = paste(.y, model_bc_rcp_name))
  
  print(.y_hist)
}

plot_histogram = function(.y) {
  
.y_hist_bc <- ggplot(data = bc_annual_values %>%
                       filter(decade %in% c(.y))) +
    geom_histogram(aes(x = annual_value), binwidth = 10) +
    facet_wrap(~variable)+
    labs(title = paste(.y, model_bc_rcp_name))

.y_hist_wc <- ggplot(data = wc_annual_values %>%
                       filter(decade %in% c(.y))) +
    geom_histogram(aes(x = annual_value), binwidth = 10) +
    facet_wrap(~variable) +
    labs(title = paste(.y, model_wc_rcp_name))
  
  print(.y_hist_bc)
  print(.y_hist_wc)
}

# ------------
# histogram for past data
# ------------

plot_histogram_past("1980s")
plot_histogram_past("1990s")
plot_histogram_past("2000s")
plot_histogram_past("2010s")
plot_histogram("2020s")

# ------------
# histogram for future data
# ------------

plot_histogram("2030s")
plot_histogram("2040s")
plot_histogram("2050s")
plot_histogram("2060s")
plot_histogram("2070s")
plot_histogram("2080s")
plot_histogram("2090s")


# ---------
# qq plots of the data to look at data normalcy
# does it follow expected values?
# ---------

# ---------
# qq plots of future data
# ---------

plot_qq = function(.y) {
  
.y_qq_bc <- ggplot(data = bc_annual_values %>%
                     filter(decade %in% (.y))) +
    geom_qq(aes(sample = annual_value)) +
    facet_wrap(~variable, scales = "free")+
    labs(title = paste(.y, model_bc_rcp_name))

.y_qq_wc <- ggplot(data = wc_annual_values %>%
                     filter(decade %in% (.y))) +
    geom_qq(aes(sample = annual_value)) +
    facet_wrap(~variable, scales = "free")+
    labs(title = paste(.y, model_wc_rcp_name))
  
  print(.y_qq_bc)
  print(.y_qq_wc)
}

plot_qq("1980s")
plot_qq("1990s")
plot_qq("2000s")
plot_qq("2010s")
plot_qq("2020s")
plot_qq("2030s")
plot_qq("2040s")
plot_qq("2050s")
plot_qq("2060s")
plot_qq("2070s")
plot_qq("2080s")
plot_qq("2090s")

```


```{r}

## Data for graphs for 40 yr. period, shifts in timing of events

# --------
# clean data for 40 yr graphs
# graphs grouped by 40 yr chunks
# graphs then grouped by doy
# mean of doy taken, to be plotted on a single line that represents the mean of the doy for that 40 yr chunk
# --------

doy_avg_1980_2019 <-  past_day %>% 
  filter(year %in% c(1980:2019)) %>%
  pivot_longer(`soil_water_daily`:`aet_daily`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>%  # new column name to store values) 
#for grouping by doy
  group_by(doy, variable) %>% 
  summarize(`1980-2019` = mean(value, na.rm = TRUE),
            month = unique(month))

# --------
# Best case means
# --------

# 2020 - 2059 Best case
# first, rename variables to be able to combine them later

doy_avg_2020_2059_bc <- future_day %>% 
  filter(year %in% c(2020:2059)) %>%
  select(soil_water_daily_bc:doy) %>% 
  pivot_longer(`soil_water_daily_bc`:`aet_daily_bc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>% # new column name to store values)
  mutate(variable = case_when(.$variable == "aet_daily_bc" ~ "aet_daily",
    .$variable == "rain_daily_bc" ~ "rain_daily",
    .$variable == "runoff_daily_bc" ~ "runoff_daily",
    .$variable == "pet_daily_bc" ~ "pet_daily",
    .$variable == "accumswe_daily_bc" ~ "accumswe_daily",
    .$variable == "soil_water_daily_bc" ~ "soil_water_daily",
    .$variable == "agdd_daily_bc" ~ "agdd_daily",
    TRUE ~ "deficit_daily")) %>% 
  group_by(doy, variable) %>% 
  summarize(`2020-2059` = mean(value, na.rm = TRUE),
            month = unique(month)) 


# 2060 - 2099 Best case df
# first, rename variables to be able to combine them later

doy_avg_2060_2099_bc <-  future_day %>% 
  filter(year %in% c(2060:2099)) %>%
  select(soil_water_daily_bc:doy) %>%
  pivot_longer(`soil_water_daily_bc`:`aet_daily_bc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>%  # new column name to store values) 
  mutate(variable = case_when(.$variable == "aet_daily_bc" ~ "aet_daily",
    .$variable == "rain_daily_bc" ~ "rain_daily",
    .$variable == "runoff_daily_bc" ~ "runoff_daily",
    .$variable == "pet_daily_bc" ~ "pet_daily",
    .$variable == "accumswe_daily_bc" ~ "accumswe_daily",
    .$variable == "soil_water_daily_bc" ~ "soil_water_daily",
    .$variable == "agdd_daily_bc" ~ "agdd_daily",
    TRUE ~ "deficit_daily")) %>% #for grouping by doy
  group_by(doy, variable) %>% 
  summarize(`2060-2099` = mean(value, na.rm = TRUE),
            month = unique(month)) 

#full doy dataframe Best case

doy_avg_bc <- doy_avg_1980_2019 %>% 
  full_join(doy_avg_2020_2059_bc) %>% 
  full_join(doy_avg_2060_2099_bc) %>% 
  pivot_longer(c(`1980-2019`,`2020-2059`,`2060-2099`), # The columns I'm gathering together
               names_to = "decades", # new column name for existing names
               values_to = "value") %>% # new column name to store values 
  na.omit(doy_avg_bc) %>%  # because of the way the dataframe was made, there's NA's for second and third 40, just don't want those there
  pivot_wider(names_from = variable,
              values_from = value)


# --------
# wc means
# --------

# 2020 - 2059 wc df
# first, rename variables to be able to combine them later

doy_avg_2020_2059_wc <- future_day %>% 
  filter(year %in% c(2020:2059)) %>%
  select(soil_water_daily_wc:doy) %>% 
  pivot_longer(`soil_water_daily_wc`:`aet_daily_wc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>% # new column name to store values)
  mutate(variable = case_when(.$variable == "aet_daily_wc" ~ "aet_daily",
    .$variable == "rain_daily_wc" ~ "rain_daily",
    .$variable == "runoff_daily_wc" ~ "runoff_daily",
    .$variable == "pet_daily_wc" ~ "pet_daily",
    .$variable == "accumswe_daily_wc" ~ "accumswe_daily",
    .$variable == "soil_water_daily_wc" ~ "soil_water_daily",
    .$variable == "agdd_daily_wc" ~ "agdd_daily",
    TRUE ~ "deficit_daily")) %>% 
  group_by(doy, variable) %>% 
  summarize(`2020-2059` = mean(value, na.rm = TRUE),
            month = unique(month)) 


# 2060 - 2099 wc df
# first, rename variables to be able to combine them later

doy_avg_2060_2099_wc <-  future_day %>% 
  filter(year %in% c(2060:2099)) %>%
  select(soil_water_daily_wc:doy) %>%
  pivot_longer(`soil_water_daily_wc`:`aet_daily_wc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>%  # new column name to store values) 
  mutate(variable = case_when(.$variable == "aet_daily_wc" ~ "aet_daily",
    .$variable == "rain_daily_wc" ~ "rain_daily",
    .$variable == "runoff_daily_wc" ~ "runoff_daily",
    .$variable == "pet_daily_wc" ~ "pet_daily",
    .$variable == "accumswe_daily_wc" ~ "accumswe_daily",
    .$variable == "soil_water_daily_wc" ~ "soil_water_daily",
    .$variable == "agdd_daily_wc" ~ "agdd_daily",
    TRUE ~ "deficit_daily")) %>% 
  group_by(doy, variable) %>% 
  summarize(`2060-2099` = mean(value, na.rm = TRUE),
            month = unique(month)) 


#full day dataset wc

doy_avg_wc <- doy_avg_1980_2019 %>% 
  full_join(doy_avg_2020_2059_wc) %>% 
  full_join(doy_avg_2060_2099_wc) %>% 
  pivot_longer(c(`1980-2019`,`2020-2059`,`2060-2099`), # The columns I'm gathering together
               names_to = "decades", # new column name for existing names
               values_to = "value") %>% # new column name to store values 
  na.omit(doy_avg_wc) %>%  # because of the way the dataframe was made, there's NA's for second and third 40, just don't want those there
  pivot_wider(names_from = variable,
              values_from = value) 


```

```{r}
# ---------
# Month data made into a joined df
# used for the jitter plots
# ---------
month_join_1980_2019 <- past_month %>% 
  pivot_longer(`soil_water_monthly`:`aet_monthly`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>% # new column name to store values
  mutate(variable = case_when(
    .$variable == "runoff_monthly" ~ "Runoff",
    #.Svariable calls the variable, then it can be renamed
    .$variable == "agdd_monthly" ~ "AGDD",
    .$variable == "soil_water_monthly" ~ "Soil Water",
    .$variable == "rain_monthly" ~ "Rain",
    .$variable == "accumswe_monthly" ~ "Accumulated SWE",
    .$variable == "pet_monthly" ~ "PET",
    .$variable == "deficit_monthly" ~ "Deficit",
    TRUE ~ "AET" # last ifelse is just labeled as TRUE
  )) %>% 
  rename("1980-2019" = value)

# --------
# Best case month data in long format
# --------

# 2020 - 2059 Best case
# first, rename variables to be able to combine them later

month_join_2020_2059_bc <- future_month %>% 
  filter(year %in% c(2020:2059)) %>%
  select(soil_water_monthly_bc:month) %>% 
  pivot_longer(`soil_water_monthly_bc`:`aet_monthly_bc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>% # new column name to store values)
  mutate(variable = case_when(.$variable == "aet_monthly_bc" ~ "AET",
    .$variable == "rain_monthly_bc" ~ "Rain",
    .$variable == "runoff_monthly_bc" ~ "Runoff",
    .$variable == "pet_monthly_bc" ~ "PET",
    .$variable == "accumswe_monthly_bc" ~ "Accumulated SWE",
    .$variable == "soil_water_monthly_bc" ~ "Soil Water",
    .$variable == "agdd_monthly_bc" ~ "AGDD",
    TRUE ~ "Deficit")) %>% 
  rename("2020-2059" = value) 
  


# 2060 - 2099 Best case df
# first, rename variables to be able to combine them later

month_join_2060_2099_bc <-  future_month %>% 
  filter(year %in% c(2060:2099)) %>%
  select(soil_water_monthly_bc:month) %>%
  pivot_longer(`soil_water_monthly_bc`:`aet_monthly_bc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>%  # new column name to store values) 
  mutate(variable = case_when(.$variable == "aet_monthly_bc" ~ "AET",
    .$variable == "rain_monthly_bc" ~ "Rain",
    .$variable == "runoff_monthly_bc" ~ "Runoff",
    .$variable == "pet_monthly_bc" ~ "PET",
    .$variable == "accumswe_monthly_bc" ~ "Accumulated SWE",
    .$variable == "soil_water_monthly_bc" ~ "Soil Water",
    .$variable == "agdd_monthly_bc" ~ "AGDD",
    TRUE ~ "Deficit"))%>% 
  rename("2060-2099" = value) 

#full doy dataframe Best case

month_join_bc <- month_join_1980_2019 %>% 
  full_join(month_join_2020_2059_bc) %>% 
  full_join(month_join_2060_2099_bc) %>% 
  pivot_longer(`1980-2019`:`2060-2099`, # The columns I'm gathering together
               names_to = "decades", # new column name for existing names
               values_to = "value") %>% # new column name to store values 
  na.omit(month_join_bc_m)# because of the way the dataframe was made, there's NA's for second and third 40, just don't want those there


# --------
# wc
# --------

# 2020 - 2059 worst case
# first, rename variables to be able to combine them later

month_join_2020_2059_wc <- future_month %>% 
  filter(year %in% c(2020:2059)) %>%
  select(soil_water_monthly_wc:aet_monthly_wc, date:month) %>% 
  pivot_longer(`soil_water_monthly_wc`:`aet_monthly_wc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>% # new column name to store values)
  mutate(variable = case_when(.$variable == "aet_monthly_wc" ~ "AET",
    .$variable == "rain_monthly_wc" ~ "Rain",
    .$variable == "runoff_monthly_wc" ~ "Runoff",
    .$variable == "pet_monthly_wc" ~ "PET",
    .$variable == "accumswe_monthly_wc" ~ "Accumulated SWE",
    .$variable == "soil_water_monthly_wc" ~ "Soil Water",
    .$variable == "agdd_monthly_wc" ~ "AGDD",
    TRUE ~ "Deficit")) %>% 
  rename("2020-2059" = value) 


# 2060 - 2099 worst case df
# first, rename variables to be able to combine them later

month_join_2060_2099_wc <-  future_month %>% 
  filter(year %in% c(2060:2099)) %>%
  select(soil_water_monthly_wc:aet_monthly_wc, date:month) %>%
  pivot_longer(`soil_water_monthly_wc`:`aet_monthly_wc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>%  # new column name to store values) 
  mutate(variable = case_when(.$variable == "aet_monthly_wc" ~ "AET",
    .$variable == "rain_monthly_wc" ~ "Rain",
    .$variable == "runoff_monthly_wc" ~ "Runoff",
    .$variable == "pet_monthly_wc" ~ "PET",
    .$variable == "accumswe_monthly_wc" ~ "Accumulated SWE",
    .$variable == "soil_water_monthly_wc" ~ "Soil Water",
    .$variable == "agdd_monthly_wc" ~ "AGDD",
    TRUE ~ "Deficit"))%>% 
  rename("2060-2099" = value) 

#full doy dataframe worst case

month_join_wc <- month_join_1980_2019 %>% 
  full_join(month_join_2020_2059_wc) %>% 
  full_join(month_join_2060_2099_wc) %>% 
  pivot_longer(`1980-2019`:`2060-2099`, # The columns I'm gathering together
               names_to = "decades", # new column name for existing names
               values_to = "value") %>% # new column name to store values 
  na.omit(month_join_wc_m)# because of the way the dataframe was made, there's NA's for second and third 40, just don't want those there

```


```{r, eval=FALSE}

# -------------------------------------------------------------------------------------
#
# GRAPH FUNCTIONS
#
# -------------------------------------------------------------------------------------


```


```{r}
# -------
# Function for 40 yr chunks - smoothed line graph by doy
# -------


plot_decades_smooth = function(.y) { #start function
  
  max_y_1 <- doy_avg_bc %>%
    full_join(doy_avg_wc) %>%
  select(.y)


max_y_2 <- max(max_y_1[,2], na.rm = TRUE)

max_y <- max_y_2*1.15

  
  exists_.y <- exists(.y, where = doy_avg_bc) #check to see if the variable exists
  
  if(exists_.y == TRUE){ #start if statement Best case
  
  .y_plot_bc <- ggplot(doy_avg_bc) + 
    geom_line(aes(x = as.Date.numeric(doy, origin = "1980-01-01"),
                   y = .data[[.y]],
                   color = decades),
               size = 0.7,
               alpha = 0.4) +
    stat_smooth(size = 1.5,
                se = FALSE,
                aes(x = as.Date.numeric(doy, origin = "1980-01-01"),#allows for month on xaxis
                    y = .data[[.y]],
                    # calling my variable, which I'll name later in the command
                    group = decades,
                    color = decades),
                method = glm,
                family = quasipoisson,
                formula = y ~ ns(x, 16)) +
    theme(legend.title = element_blank())+
    #internet said to do this
    #quasipoisson is some type of statistical analysis type
    #forumula has something to do with the degrees of freedom
    #https://stackoverflow.com/questions/2777053/in-ggplot-restrict-y-to-be-0-in-loess
    # geom_vline(data = doy_avg_bc,
    #            xintercept = doy[.data[[.y]] == max(.data[[.y]])], color='red') +
    labs(color = "Year",
         y = ifelse(.y == "agdd_daily", "Growing Degree Days (C)", "Water (mm)"), 
         # R needs the "" here
         # the ifelse goes after the command you want to change
         #.y is useful because it prevents R from confusing it with something else
         # purrr is much more useful than a for loop here
         # if {} else{} and if_else() both didn't work, but I don't know why
         title = case_when(.y ==  "soil_water_daily" ~ 
                             paste("Soil Water Seasonality", "\n",
                                   model_bc, " ",model_bc_rcp_name, sep = ""), #title based on variable
                           .y == "runoff_daily" ~ 
                             paste("Runoff Seasonality", "\n",
                                   model_bc, " ",model_bc_rcp_name, sep = ""),
                           .y == "rain_daily" ~  
                             paste("Rain Seasonality","\n",
                                   model_bc, " ",model_bc_rcp_name, sep = ""),
                           .y == "agdd_daily" ~ 
                             paste("AGDD Seasonality","\n",
                                   model_bc, " ",model_bc_rcp_name, sep = ""),
                           .y == "accumswe_daily"~ paste(
                              "SWE Seasonality", "\n",
                                   model_bc, " ",model_bc_rcp_name, sep = ""),
                           .y == "pet_daily" ~ paste(
                               "PET Seasonality", "\n",
                               model_bc, " ",model_bc_rcp_name, sep = ""),
                           .y == "deficit_daily" ~ 
                             paste("Deficit Seasonality", "\n",
                                   model_bc, " ",model_bc_rcp_name, sep = ""),
                           TRUE ~ paste(
                               "AET Seasonality", "\n",
                                   model_bc, " ",model_bc_rcp_name, sep = ""))) + 
    scale_color_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                       values = c("#A3B86C", "#EBC944", "#1496BB")) +
    ylim(0, max_y) +
    scale_x_date(as.Date.numeric(doy_avg_bc$doy, origin = "1980-01-01"),
                 breaks = seq(as.Date("1980-01-15"), 
                            as.Date("1980-12-15"),#plots dates midmonth
                            by = "1 month"),
                 date_labels = "%b")#%b is abbreviated %B is full month name
    
# gb <- ggplot_build(.y_plot_bc)
# 
#   vline_data_bc <- 
#     gb$data[[1]] %>% 
#     group_by(group) %>% 
#     summarize(xintercept = x[which(y == max(y))])
#  
#   .y_plot_bc <- .y_plot_bc + geom_vline(aes(xintercept = xintercept), data = vline_data_bc)
  
  if(save_images == TRUE){
  ggsave(here::here("sites",
                    site, # site subfolder
                    "figures", #sub folder
                    paste("lat",lat,"lon",lon, sep = "_"),
                    "40_yr_graphs", # subfolder
                    paste(.y, "40_yr", model_bc_rcp, ".png", sep = "_"))) #file name
}
  print(.y_plot_bc)
  
  } #end if statement for Best case
  
  exists_.y <- exists(.y, where = doy_avg_wc) #check to see if the variable exists
  
  if(exists_.y == TRUE){ #start if statement RCP 8.5
  
  .y_plot_wc <- ggplot(doy_avg_wc) +
    geom_line(aes(x = as.Date.numeric(doy, origin = "1980-01-01"),
                   y = .data[[.y]],
                   color = decades),
               size = 0.7,
               alpha = 0.4) +
    stat_smooth(size = 1.5,
                se = FALSE,
                aes(x = as.Date.numeric(doy, origin = "1980-01-01"),#allows for month on xaxis
                    y = .data[[.y]],
                    # calling my variable, which I'll name later in the command
                    group = decades,
                    color = decades),
                method = glm,
                family = quasipoisson,
                formula = y ~ ns(x, 16)) +
    theme(legend.title = element_blank()) +
        #internet said to do this
    #quasipoisson is some type of statistical analysis type
    #forumula has something to do with the degrees of freedom
    #https://stackoverflow.com/questions/2777053/in-ggplot-restrict-y-to-be-0-in-loess
    #geom_vline(xintercept = doy[.data[[.y]] == max(.data[[.y]])],color='red') +
    labs(color = "Year",
         y = ifelse(.y == "agdd_daily", "Growing Degree Days (C)", "Water (mm)"), 
         # R needs the "" here
         # the ifelse goes after the command you want to change
         #.y is useful because it prevents R from confusing it with something else
         # purrr is much more useful than a for loop here
         # if {} else{} and if_else() both didn't work, but I don't know why
         title = case_when(.y ==  "soil_water_daily" ~ 
                             paste("Soil Water Seasonality", "\n",
                                   model_wc, " ",model_wc_rcp_name, sep = ""), #title based on variable
                           .y == "runoff_daily" ~ 
                             paste("Runoff Seasonality", "\n",
                                   model_wc, " ",model_wc_rcp_name, sep = ""),
                           .y == "rain_daily" ~  
                             paste("Rain Seasonality", "\n",
                                   model_wc, " ",model_wc_rcp_name, sep = ""),
                           .y == "agdd_daily" ~ 
                             paste("AGDD Seasonality", "\n",
                                   model_wc,model_wc_rcp_name),
                           .y == "accumswe_daily"~ 
                            paste(
                              "SWE Seasonality", "\n",
                                   model_wc,model_wc_rcp_name),
                           .y == "pet_daily" ~ 
                             paste(
                               "Potential Evapotranspiration Seasonality", "\n",
                               model_wc,model_wc_rcp_name),
                           .y == "deficit_daily" ~ 
                             paste("Deficit Seasonality", "\n",
                                   model_wc, " ",model_wc_rcp_name, sep = ""),
                           TRUE ~ 
                             paste(
                               "Actual Evapotranspiration Seasonality", "\n",
                                   model_wc, " ",model_wc_rcp_name, sep = ""))) +
    scale_color_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                       values = c("#A3B86C", "#EBC944", "#1496BB")) +
  ylim(0, max_y)+
    scale_x_date(as.Date.numeric(doy_avg_bc$doy, origin = "1980-01-01"),
                 breaks = seq(as.Date("1980-01-15"), 
                            as.Date("1980-12-15"), #plots date at midmonth
                            by = "1 month"),
                 date_labels = "%b")#%b is abbreviated, %B is full month name
  # gb <- ggplot_build(.y_plot_bc)
  # 
  # vline_data_wc <- 
  #   gb$data[[1]] %>% 
  #   group_by(group) %>% 
  #   summarize(xintercept = x[which(y == max(y))])
  # 
  # .y_plot_wc <- .y_plot_wc + geom_vline(aes(xintercept = xintercept), data = vline_data_wc)
  
  if(save_images == TRUE){
  ggsave(here::here("sites",
                    site, #site subfolder
                    "figures", #top folder
                    paste("lat",lat,"lon",lon, sep = "_"),
                    "40_yr_graphs", # subfolder
                    paste(.y, "40_yr", model_wc_rcp, ".png", sep = "_"))) #file name
  }
  
  print(.y_plot_wc)
  
  } #end if statement worst case

  
} #end function decades_smooth



# ---------
# function for line graph
# ---------



plot_decades_line = function(.y) { #start function
  
  max_y_1 <- doy_avg_bc %>%
    full_join(doy_avg_wc) %>%
  select(.y)


max_y_2 <- max(max_y_1[,2], na.rm = TRUE)

max_y <- max_y_2*1.15
  
  exists_.y <- exists(.y, where = doy_avg_bc) #check to see if the variable exists
  
  if(exists_.y == TRUE){ #start if statement Best case

.y_plot_bc <- ggplot(doy_avg_bc) + 
    geom_line(size = 1.5,
                aes(x = as.Date.numeric(doy, origin = "1980-01-01"),#plots month on x axis
                    y = .data[[.y]],
                    # calling my variable, which I'll name later in the command
                    group = decades,
                    color = decades)) +
  theme(legend.title = element_blank()) +
    #internet said to do this
    #quasipoisson is some type of statistical analysis type
    #forumula has something to do with the degrees of freedom
    #https://stackoverflow.com/questions/2777053/in-ggplot-restrict-y-to-be-0-in-loess
    # geom_vline(data = doy_avg_bc,
    #            xintercept = doy[.data[[.y]] == max(.data[[.y]])], color='red') +
    labs(color = "Year",
         y = ifelse(.y == "agdd_daily", "Growing Degree Days (C)", "Water (mm)"), 
         # R needs the "" here
         # the ifelse goes after the command you want to change
         #.y is useful because it prevents R from confusing it with something else
         # purrr is much more useful than a for loop here
         # if {} else{} and if_else() both didn't work, but I don't know why
         title = case_when(.y ==  "soil_water_daily" ~ 
                             paste("Soil Water Seasonality", "\n",
                                   model_bc, " ",model_bc_rcp_name, sep = ""), #title based on variable
                           .y == "runoff_daily" ~ 
                             paste("Runoff Seasonality", "\n",
                                   model_bc, " ",model_bc_rcp_name, sep = ""),
                           .y == "rain_daily" ~  
                             paste("Rain Seasonality", "\n",
                                   model_bc, " ",model_bc_rcp_name, sep = ""),
                           .y == "agdd_daily" ~ 
                             paste("AGDD Seasonality", "\n",
                                   model_bc,model_bc_rcp_name),
                           .y == "accumswe_daily"~ 
                            paste(
                              "Peak SWE Seasonality", "\n",
                                   model_bc,model_bc_rcp_name),
                           .y == "pet_daily" ~ 
                             paste(
                               "Potential Evapotranspiration Seasonality", "\n",
                               model_bc,model_bc_rcp_name),
                           .y == "deficit_daily" ~ 
                             paste("Deficit Seasonality", "\n",
                                   model_bc, " ",model_bc_rcp_name, sep = ""),
                           TRUE ~ 
                             paste(
                               "Actual Evapotranspiration Seasonality", "\n",
                                   model_bc, " ",model_bc_rcp_name, sep = ""))) +
    scale_color_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                       values = c("#A3B86C", "#EBC944", "#1496BB")) +
  ylim(NA, max_y) +
    scale_x_date(as.Date.numeric(doy_avg_bc$doy, origin = "1980-01-01"),
                 breaks = seq(as.Date("1980-01-15"), 
                            as.Date("1980-12-15"),#moves breaks to midmonth
                            by = "1 month"),
                 date_labels = "%b")# %b gives abbreviated %B gives full month name
  
if(save_images == TRUE){
  ggsave(here::here("sites",
                    site, # site subfolder
                    "figures", #sub folder
                    paste("lat",lat,"lon",lon, sep = "_"),
                    "40_yr_graphs", # subfolder
                    paste(.y, "40_yr_line",model_bc_rcp, ".png", sep = "_"))) #file name
  print(.y_plot_bc)
}
  
  } # end if statement rcp bc
  
  exists_.y <- exists(.y, where = doy_avg_wc) #check to see if the variable exists
  
  if(exists_.y == TRUE){ #start if statement best case
  
  .y_plot_wc <- ggplot(doy_avg_wc) +
    geom_line(size = 1.5,
                aes(x = as.Date.numeric(doy, origin = "1980-01-01"),#allows months to plot on x axis
                    y = .data[[.y]],
                    # calling my variable, which I'll name later in the command
                    group = decades,
                    color = decades)) +
    theme(legend.title = element_blank()) +
    labs(color = "Year",
         y = ifelse(.y == "agdd_daily", "Growing Degree Days (C)", "Water (mm)"), 
         # R needs the "" here
         # the ifelse or case_when goes after the command you want to change
         #.y is useful because it prevents R from confusing it with something else
         title = case_when(.y ==  "soil_water_daily" ~ 
                             paste("Soil Water Seasonality", "\n",
                                   model_wc, " ",model_wc_rcp_name, sep = ""), #title based on variable
                           .y == "runoff_daily" ~ 
                             paste("Runoff Seasonality", "\n",
                                   model_wc, " ",model_wc_rcp_name, sep = ""),
                           .y == "rain_daily" ~  
                             paste("Rain Seasonality",
                                   model_wc, " ",model_wc_rcp_name, sep = ""),
                           .y == "agdd_daily" ~ 
                             paste("AGDD Seasonality", "\n",
                                   model_wc,model_wc_rcp_name),
                           .y == "accumswe_daily"~ 
                            paste(
                              "Peak SWE Seasonality", "\n",
                                   model_wc,model_wc_rcp_name),
                           .y == "pet_daily" ~ 
                             paste(
                               "Potential Evapotranspiration Seasonality", "\n",
                               model_wc,model_wc_rcp_name),
                           .y == "deficit_daily" ~ 
                             paste("Deficit Seasonality", "\n",
                                   model_wc, " ",model_wc_rcp_name, sep = ""),
                           TRUE ~ 
                             paste(
                               "Actual Evapotranspiration Seasonality",
                                   model_wc, " ",model_wc_rcp_name, sep = ""))) +
    scale_color_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                       values = c("#A3B86C", #turquoise
                                  "#EBC944", #green
                                  "#1496BB")) +#yellow
    ylim(NA, max_y) +
    scale_x_date(as.Date.numeric(doy_avg_bc$doy, origin = "1980-01-01"),
                 breaks = seq(as.Date("1980-01-15"), 
                            as.Date("1980-12-15"),#sets labels at the middle of the month
                            by = "1 month"),
                 date_labels = "%b")
  
  if(save_images == TRUE){
  ggsave(here::here("sites",
                    site, #site subfolder
                    "figures", #top folder
                    paste("lat",lat,"lon",lon, sep = "_"),
                    "40_yr_graphs", # subfolder
                    paste(.y, "40_yr_line",model_wc_rcp, ".png", sep = "_"))) #file name
  }
  
  print(.y_plot_wc)
  
  } #end if statement RCP 8.5
  
  
  
} #end function decades_line

# call graphs later



  
```


```{r, out.width="50%"}
## Individual Graphs of change over time

plot_annual = function(.y) {
   
   point_low <- annual_values %>%
     filter(variable %in% c(.y)) %>% 
     filter(year == dry_year)
   
   point_high<- annual_values %>%
     filter(variable %in% c(.y)) %>% 
     filter(year == wet_year)
   
   line_low <- point_low$annual_value
   
   line_high <- point_high$annual_value
   
   # ---------------
   # create y limit for graph
   # ---------------
   
    max_y_1 <- annual_values %>%
      filter(variable %in% c(.y))
    
    max_y_2 <- max(max_y_1[,3], na.rm = TRUE)
    
    max_y <- max_y_2*1.15
    
    # ---------------
    # graph
    # ---------------
  
  annual_graph_bc <- ggplot() +
    geom_line(data = annual_values %>% 
                filter(averages %in% c("annual_avg", "annual_avg_bc")) %>% 
                filter(variable == .y), # filter data for historical and bc lines
              aes(x = year, 
                  y = annual_value, 
                  color = averages),
              size = .75) +
    geom_hline(data = point_low, # draws a line at a dry year
               yintercept = line_low, 
               linetype = "dashed",
               color = "#DA621E") +
    geom_hline(data = point_high, # draws a line at a wet year
               yintercept = line_high, 
               linetype = "dashed",
               color = "#1287A8") +
    geom_point(data = point_low, # highlights a dry year point
               aes(x = year, y = annual_value),
               color = "#DA621E",
               alpha =  0.25,
               size = 4) +
    geom_point(data = point_high, # highlights a dry year point
               aes(x = year, y = annual_value),
               color = "#1287A8",
               alpha =  0.25,
               size = 4) +
  labs(title = paste("Annual", .y, "\n", model_bc, " ",model_bc_rcp_name, sep = ""),
       y = ifelse(.y == "agdd_daily", "Growing Degree Days (C)",
                    "Water (mm)")) +
      geom_text(data = point_low, # labels the line
              aes(x = 1967, 
                  y = annual_value,
                  label = paste("Dry year:", year), 
                  vjust = -0.35), # -0.x moves the text up above the line
              color = "#DA621E") +
    geom_text(data = point_high, # labels the line
              aes(x = 1967, 
                  y = annual_value,
                  label = paste("Wet year:", year), 
                  vjust = -0.35), # -0.x moves the text up above the line
              color = "#1287A8") +
    scale_color_manual(name = "", values = c("gray60","#A3B86C"), labels = (c(paste(past_data), paste(model_bc, model_bc_rcp_name)))) + # colors is a named vector, see top of function
 ylim(NA, max_y) +
      xlim(1960.5, NA)
  
    if(save_images == TRUE){
  ggsave(here::here("sites",
                    site, #site subfolder
                    "figures", #subfolder
                    paste("lat",lat,"lon",lon,sep = "_"),
                    paste(.y, "annual_graph_bc.png", sep = "_"))) #file name
    }
  
  annual_graph_wc <- ggplot() +
    geom_line(data = annual_values %>% 
                filter(averages %in% c("annual_avg", "annual_avg_wc")) %>%
                filter(variable == .y), # filter data for historical and wc lines
              aes(x = year, 
                  y = annual_value, 
                  color = averages),
              size = .75) +
    geom_hline(data = point_low, 
               yintercept = line_low, 
               linetype = "dashed",
               color = "#DA621E") +
    geom_hline(data = point_high, # draws a line at a wet year
               yintercept = line_high, 
               linetype = "dashed",
               color = "#1287A8") +
    geom_point(data = point_low, # highlights a dry year point
               aes(x = year, y = annual_value),
               color = "#DA621E",
               alpha =  0.25,
               size = 4) +
    geom_point(data = point_high, # highlights a dry year point
               aes(x = year, y = annual_value),
               color = "#1287A8",
               alpha =  0.25,
               size = 4) +
  labs(title = paste("Annual ", .y, "\n", model_wc, " ", model_wc_rcp_name, sep = ""),
       y = ifelse(.y == "ADGG", "Growing Degree Days (C)",
                    "Water (mm)")) +
    geom_text(data = point_low, # labels the line
              aes(x = 1967, 
                  y = annual_value,
                  label = paste("Dry year:", year), 
                  vjust = -0.35), # -0.x moves the text up above the line
              color = "#DA621E") +
    geom_text(data = point_high, # labels the line
              aes(x = 1967, 
                  y = annual_value,
                  label = paste("Wet year:", year), 
                  vjust = -0.35), # -0.x moves the text up above the line
              color = "#1287A8") +
    scale_color_manual(name = "", values = c("gray60", "#EBC944"), labels = (c(paste(past_data), paste(model_wc, model_wc_rcp_name)))) + # colors is a named vector, see top of function
  ylim(NA, max_y) +
    xlim(1960.5, NA)
  
  if(save_images == TRUE){
  ggsave(here::here("sites",
                    site, #site subfolder
                    "figures", #subfolder
                    paste("lat",lat,"lon",lon, sep = "_"),
                    paste(.y, "annual_graph_wc.png", sep = "_"))) #filename
  }
  
  # return(annual_graph_bc)
  # return(annual_graph_wc) with these two it only prints the 4.5 graph
  
  print(annual_graph_bc)
  print(annual_graph_wc)
  
}


```

```{r}

# --------
# jitter under boxplot
# --------

plot_jitter <- function(.y){
  
   max_y_1 <- month_join_bc %>%
     full_join(month_join_wc) %>% 
      filter(variable %in% c(.y))
    
    max_y_2 <- max(max_y_1[,6], na.rm = TRUE) #calling the values column, number 6
    
    max_y <- max_y_2*1.15
# ---------
# jitter best case
# ---------

dodge <- position_dodge(width = 1)

jitter_bc <- ggplot(data =  month_join_bc %>%
         filter(variable %in% c(.y)),
       aes(x = decades, 
           y = value, 
           shape = NULL)) + #originally had "group = decade" here
                            # this caused the facet_wrap to include all variables on all facets
  geom_jitter(aes(colour = decades),
             size = 3,
             alpha = 0.25) + # dodge is a written code (see above)
  geom_boxplot(aes(x = decades, # internet had "mapping =" in front of
                   # aes, removed and nothing changed
                   y = value),
               alpha = 0.3,
               nudge = 0.025,
               outlier.shape = NA,#hides outliers
               #position = dodge, # has to match the other half
               fill = "grey60") +
  scale_color_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                     values = c("#A3B86C", "#EBC944", "#1496BB")) +
  scale_fill_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                     values = c("#A3B86C", "#EBC944", "DA621E")) +
  labs(y = "Water(mm)",
       title = paste("Annual ", .y, "\n", model_bc, " ", model_bc_rcp_name, sep = "")) +
  guides(color = guide_legend(override.aes = list(size=5, #changes size of legend dots
                                                  alpha = 0.5)))+
  theme(legend.title = element_blank()) +
  ylim(NA, max_y)

if(save_images == TRUE){
ggsave(here::here("sites",
                  site, #site subfolder
                  "figures", #subfolder
                  paste("lat",lat,"lon",lon, sep = "_"),
                  paste("jitter_bc_",.y,".png", sep = ""))) # file name
}

# ----------
# Jitter worst case
# ----------


jitter_wc <- ggplot(data =  month_join_wc %>%
         filter(variable %in% c(.y)),
       aes(x = decades, 
           y = value, 
           shape = NULL)) + #originally had "group = decade" here
                            # this caused the facet_wrap to include all variables on all facets
  geom_jitter(aes(colour = decades),
             size = 3,
             alpha = 0.25) + # dodge is a written code (see above)
  geom_boxplot(aes(x = decades, # internet had "mapping =" in front of
                   # aes, removed and nothing changed
                   y = value),
               alpha = 0.3,
               nudge = 0.025,
               outlier.shape = NA,#hides outliers
               #position = dodge, # has to match the other half
               fill = "grey60") +
  scale_color_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                     values = c("#A3B86C", "#EBC944", "#1496BB")) +
  scale_fill_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                     values = c("#A3B86C", "#EBC944", "#1496BB")) +
  labs(y = "Water(mm)",
       title = paste("Annual ",.y, "\n", model_wc, " ", model_wc_rcp_name, sep = "")) +
  guides(color = guide_legend(override.aes = list(size=5,
                                                  alpha = 0.5)))+
  theme(legend.title = element_blank()) +
  ylim(NA, max_y)

if(save_images == TRUE){
ggsave(here::here("sites",
                  site, #site subfolder
                  "figures", #subfolder
                  paste("lat",lat,"lon",lon, sep = "_"),
                  paste("jitter_wc_", .y,".png", sep = "_"))) # file name
}

print(jitter_bc)
print(jitter_wc)
}


```


```{r}

# --------------------------------------------------------------------------------------
#
# BEGIN OF ACTUAL REPORT
#
# --------------------------------------------------------------------------------------

```

Water balance is the mathematical accounting of water input and movement through the environment.  It accounts for water storage in different phases (ice, liquid) and loss to the atmosphere (gas) via evapotranspiration.  Through integrating the interactions of temperature and precipitation, it allows us to estimate water availability, movement to streams, and ground water and use by plants. It also accounts for heat load on different aspects and slopes in complex terrain, as well as water holding capacity of different soil types. Local site characteristics such as slope, aspect, soil properties are represented by the modification of regional weather and climate and depict the biophysical conditions at local scales that plants and animals “experience”.  For these reasons, water balance is usually more strongly correlated with natural resource response (plant growth, stream flow, fire danger) than temperature or precipitation. More information about water balance and links to studies that have used water balance to improve
understanding of natural resources response to climate change can be found [here](https://www.nps.gov/subjects/climatechange/waterbalance.htm). The water balance model is maintained by the National Park Service (Mike Tercek, David Thoma and John Gross).  Collectively this report summarizes historical and projected biophysical environmental conditions from 1980-2100 at the single grid cell level (`r past_data` = 4km; projections = 1km).   A link to the NPS water balance gridded products can be found [here](http://www.yellowstone.solutions/thredds/catalog.html).

```{r mccabe, echo=FALSE, fig.align="center", out.width="60%"}

knitr::include_graphics(here::here("figures","mccabe_and_markstrom.png"))

```
```{r website, results="hide"}

website <- ifelse(past_data == "gridMET", print("[gridMET](http://www.climatologylab.org/gridmet.html)"), print("[Daymet](https://daymet.ornl.gov/)"))

```

This report is created from temperature and precipitation data that is input to a water balance model.  The historical temperature and precipitation data are from `r website`. The future climate projections, `r model_bc` `r model_bc_rcp_name` and `r model_wc` `r model_wc_rcp_name`, used in this report are from the [CMIP5 experiments](https://www.wcrp-climate.org/wgcm-cmip/wgcm-cmip5) .  

\newpage

# Future Model Selection

The models used in this analysis were chosen based on two climate futures that bracket a wide range of plausible future climate conditions represented by the Global Circulation Models (GCM) in the CMIP5 experiments. The experiments include the effects of anthropogenic warming caused by changes in carbon dioxide concentration in the atmosphere.  Representative Concentration Pathways (RCP) describe scenarios of carbon dioxide emission, where RCP 8.5 is the high-emission scenario and RCP 4.5 is a lower emission scenario.  Model selection for this report is based on a temperature v. precipitation scatterplot of future climate models and scenarios at mid-century. Users are cautioned that the two models presented in this report are intended to represent a range of conditions, but other projections are available and may need to be considered for a full accounting of possible futures. The spatial resolution of climate data used in the water balance model may not be representative of site-specific conditions, especially in areas of high relief or high topographic complexity, and high variation in soil water holding capacity.

```{r}
aet_d_true <- file.exists(here::here("sites",
                          site,
                          "raw_data",
                          paste("lat",lat,"lon",lon, sep = "_"),
                          "future_aet_d.csv"))
temp_precip_alt <- !file.exists(here::here("sites",
                          site,
                          "raw_data",
                          paste("lat",lat,"lon",lon, sep = "_"),
                          "future_aet_d.csv"))

```

`r if(aet_d_true){"The preferred method is using AET and D because they are more representative of conditions experienced by plants and animals. Data can be downloaded to select models based on a range of actual evapotranspiration and deficit conditions. The models are selected from corners of the scatter plot to bracket a wide range of possible future conditions. In the western U.S. futures are selected from the scatter plot lower right quadrant representing hotter and drier future conditions or upper left representing warmer and wetter future conditions. The graph below displays a scatterplot of these models."}`

`r if(temp_precip_alt){"Projected water balance conditions presented in this report were selected based on the scatter in projected temperature and precipitation in the future. The latitude and longitude of the site is used to buid a scatterplot visualization of future projections from the MACA website of all modeled future conditions of temperature and precipitation. Models from the scatterplot are selected to represent a drier and hotter climate future (the bottom right of the scatterplot) and a wetter and hotter climate future (the upper left of the scatterplot)."}` 

<br>
<br>

```{r, eval = aet_d_true}

aet_d_past <- read_csv(here::here("sites",
                               site,
                               "raw_data",
                               paste("lat",lat,"lon",lon, sep = "_"),
                               "historical_aet_d.csv")) %>% 
  mutate(year = year(date)) %>% 
  mutate(time = "past",
         rcp = "past",
         model = "gridMET") %>% 
  group_by(year) %>% 
  summarize(deficit_past_total = unique(sum(deficit_monthly)),
         aet_past_total = unique(sum(aet_monthly)),
         time = unique(time),
         rcp = unique(rcp),
         model = unique(model)) %>% 
  summarize(deficit_past = mean(deficit_past_total),
            aet_past = mean(aet_past_total),
            time = unique(time),
            rcp = unique(rcp),
            model = unique(model))


RCPs <- as.character(c(45, 85))

d_future <- read_csv(here::here("sites", 
                               site, 
                               "raw_data", 
                               paste("lat",lat,"lon",lon, sep = "_"), 
                               "future_aet_d.csv")) %>% 
  mutate(year = year(date)) %>% 
  mutate(time = "future") %>% 
  select(!c(aet_monthly_45,aet_monthly_85)) %>% 
  pivot_longer(c(deficit_monthly_45, deficit_monthly_85),
               names_to = "rcp",
               values_to = "deficit") %>% 
  mutate(rcp = as.character(str_extract_all(rcp, RCPs))) %>% 
  mutate(rcp = case_when(.$rcp == "45" ~ "RCP 4.5",
                         TRUE ~ "RCP 8.5")) %>%
  group_by(time, model, rcp, year) %>%
  summarize(deficit_total = sum(deficit, na.rm = TRUE)) %>% 
  summarize(avg_deficit = mean(deficit_total, na.rm = TRUE),
            time = unique(time)) %>% 
  ungroup(time, model, rcp)


aet_future <- read_csv(here::here("sites", 
                               site, 
                               "raw_data", 
                               paste("lat",lat,"lon",lon, sep = "_"), 
                               "future_aet_d.csv")) %>% 
  select(!c(deficit_monthly_45,deficit_monthly_85)) %>% 
  mutate(year = year(date)) %>% 
  mutate(time = "future") %>%  
  pivot_longer(aet_monthly_45:aet_monthly_85,
               names_to = "rcp",
               values_to = "aet") %>% 
  mutate(rcp = as.character(str_extract_all(rcp, RCPs))) %>% 
  mutate(rcp = case_when(.$rcp == "45" ~ "RCP 4.5",
                         TRUE ~ "RCP 8.5")) %>% 
  group_by(time, model, rcp, year) %>% 
  summarize(aet_total = sum(aet, na.rm = TRUE)) %>% 
  summarize(avg_aet = mean(aet_total, na.rm = TRUE),
            time = unique(time)) %>% 
  ungroup(time, model, rcp)


aet_d_future <- aet_future %>% 
  inner_join(d_future)

aet_d <- aet_d_future %>% 
  full_join(aet_d_past) 

aet_d_difference <- aet_d  %>% 
  fill(aet_past, deficit_past, .direction = "up") %>% 
  mutate(aet_diff = avg_aet - aet_past,
         deficit_diff = avg_deficit - deficit_past) %>% 
  mutate(aet_percent_change = (((avg_aet - aet_past) / aet_past) * 100),
         deficit_percent_change = (((avg_deficit - deficit_past) / deficit_past) * 100)) %>% 
  mutate(model_rcp = paste(model, rcp)) 

#%>% # work to do something here with setting the quantiles like amber did in her data
#  mutate(climate_future = case_when())


ggplot(data = aet_d_difference, aes(x = deficit_diff, y = aet_diff)) +
  geom_point() +
  geom_label_repel(aes(label = model_rcp), max.overlaps = 24)


ggplot(data = aet_d_difference, aes(x = deficit_percent_change, y = aet_percent_change)) +
  geom_point() +
  geom_text_repel(aes(label = model_rcp))

```


```{r, eval = temp_precip_alt, include=FALSE}

FM <- read_csv(here::here("sites",
                          site,
                          "raw_data",
                          paste("lat",lat,"lon",lon, sep = "_"),
                          paste(site, "_t_v_p.txt", sep = "")),
               skip = 7)

  colnames(FM) <- c("model", "t_rcp45_f", "p_rcp45_in", "t_rcp85_f", "p_rcp85_in")

temp <- FM %>% 
  select(model, t_rcp45_f,t_rcp85_f) %>%
  pivot_longer(col = c(t_rcp45_f,t_rcp85_f),
               names_to = "rcp",
               values_to = "temp") %>% 
  mutate(model = case_when(rcp == "t_rcp45_f" ~ paste(model, "RCP 4.5"),
                           TRUE ~ paste(model, "RCP 8.5"))) %>% 
  select(model, temp)

precip <- FM %>% 
  select(model, p_rcp45_in,p_rcp85_in) %>% 
  pivot_longer(col = c(p_rcp45_in, p_rcp85_in),
               names_to = "rcp",
               values_to = "precip") %>% 
  mutate(model = case_when(rcp == "p_rcp45_in" ~ paste(model, "RCP 4.5"),
                           TRUE ~ paste(model, "RCP 8.5"))) %>% 
  select(model, precip)

t_v_p <- temp %>% 
  full_join(precip) 

t_v_p_filtered <- t_v_p %>% 
   filter(!model %in% c("CCSM4 RCP 4.5", "CCSM4 RCP 8.5", "inmcm4 RCP 4.5", "inmcm4 RCP 8.5", "NorESM1-M RCP 4.5", "NorESM1-M RCP 8.5", "MRI-CGCM3 RCP 4.5", "MRI-CGCM3 RCP 8.5", "MIROC5 RCP 4.5", "MIROC5 RCP 8.5", "IPSL-CM5A-LR RCP 4.5", "IPSL-CM5A-LR RCP 8.5",  "HadGEM2-CC365 RCP 4.5", "HadGEM2-CC365 RCP 8.5", "GFDL-ESM2G RCP 4.5", "GFDL-ESM2G RCP 8.5", "CanESM2 RCP 4.5", "CanESM2 RCP 8.5", "CSIRO-Mk3-6-0 RCP 4.5", "CSIRO-Mk3-6-0 RCP 8.5", "CNRM-CM5 RCP 4.5", "CNRM-CM5 RCP 8.5", "BNU-ESM RCP 4.5", "BNU-ESM RCP 8.5"))

highlight <- t_v_p %>% 
  filter(model %in% c(paste(model_bc, model_bc_rcp_name), paste(model_wc, model_wc_rcp_name)))

t_v_p_mike_server_highlight <- t_v_p %>% 
  filter(model %in% c("CCSM4 RCP 4.5", "CCSM4 RCP 8.5", "inmcm4 RCP 4.5", "inmcm4 RCP 8.5", "NorESM1-M RCP 4.5", "NorESM1-M RCP 8.5", "MRI-CGCM3 RCP 4.5", "MRI-CGCM3 RCP 8.5", "MIROC5 RCP 4.5", "MIROC5 RCP 8.5", "IPSL-CM5A-LR RCP 4.5", "IPSL-CM5A-LR RCP 8.5",  "HadGEM2-CC365 RCP 4.5", "HadGEM2-CC365 RCP 8.5", "GFDL-ESM2G RCP 4.5", "GFDL-ESM2G RCP 8.5", "CanESM2 RCP 4.5", "CanESM2 RCP 8.5", "CSIRO-Mk3-6-0 RCP 4.5", "CSIRO-Mk3-6-0 RCP 8.5", "CNRM-CM5 RCP 4.5", "CNRM-CM5 RCP 8.5", "BNU-ESM RCP 4.5", "BNU-ESM RCP 8.5")) %>% 
  filter(!model %in% c(paste(model_bc, model_bc_rcp_name), paste(model_wc, model_wc_rcp_name)))
  


set.seed(1234)

colors <- c("Models avialable on thredds server" = "black", "Models not available on thredds server" = "gray50", "Models selected for this report" = "red")

ggplot(t_v_p_filtered, aes(x = temp, y = precip)) +
  geom_point(size = 4,
             aes(colour = "Models not available on thredds server")) +
  geom_text_repel(aes(label = model, color = "Models not available on thredds server"),
                  box.padding = 0.5,
                  point.padding = 1.5) +
  geom_point(data = highlight, aes(x = temp, y = precip, 
                                   color = "Models selected for this report"),
             size = 6) +
   geom_text_repel(data = highlight, aes(label = model, 
                                         color = "Models selected for this report"),
                  box.padding = 0.5,
                  point.padding = 1.5) +
  geom_point(data = t_v_p_mike_server_highlight, aes(x = temp, y = precip, color = "Models avialable on thredds server"),
             size = 6) +
   geom_text_repel(data = t_v_p_mike_server_highlight, aes(label = model, color = "Models avialable on thredds server"),
                  box.padding = 0.5,
                  point.padding = 1.5) +
  theme(axis.text=element_text(size=20, face = "bold"),
        axis.title.x=element_text(size=20,vjust=-0.2),
        axis.title.y=element_text(size=20,vjust=0.2),
        plot.title=element_text(size=26,face="bold",vjust=2,hjust=0.5),
        legend.text=element_text(size=20), legend.title=element_text(size=20),
        legend.position = "top",
        panel.background = element_rect(fill = "gray95",
                                colour = "gray95",
                                size = 0.5, linetype = "solid")) +
  ###
  labs(title ="Changes in climate means centered on 2040\n relative to historical period (1950-2000) by GCM\n", 
       x = "Change in Temperature (F)",
       y = "Change in Precipitation (in)",
       color = "") +
  scale_color_manual(values = colors)
  

ggsave(here::here("sites",
                  site, 
                  "figures",
                  paste("lat_", lat, "_lon_", lon, sep = ""), 
                  paste(site, "Scatter BY SCENARIO.png",sep="")),
       width = 15, height = 9)

```


```{r t_v_p, echo=FALSE, fig.align="center"}

knitr::include_graphics(here::here("sites",
                  site, 
                  "figures",
                  paste("lat_", lat, "_lon_", lon, sep = ""), 
                  paste(site, "Scatter BY SCENARIO.png",sep="")))

```



\newpage

## Change in annual values through time

Runoff, rain, potential evapotranspiration (PET), actual evapotranspiration (AET), and deficit are summed to show annual values through time. Peak snow water equivalent (SWE) is the max value for the year regardless of the month in which it occurs. Soil water is the mean annual water content in the top meter soil profile. Additionally, it is important to note that precipitation includes rain plus snow, whereas rain is only liquid precipitation. Rain is specifically precipitation that does not fall as snow. If total precipitation stayed the same but temperatures increased, the data here would display that as an increase in rain.

The reason for the different summary statistics is because water variables that don’t have an upper limit like rain, runoff, evapotranspiration and deficit can accumulate indefinitely within a calendar year, whereas soil moisture is limited by the soil water holding capacity, so it is averaged on an annual basis.  Temperature variables are averaged by convention and growing degree days are summed to account for the seasonal accumulation of heat that controls biological metabolism and thus growth rates and phenology when water is available. Snow water equivalent is reported as a maximum value because snow accumulates during winter and the maximum water content of the snowpack is useful for predicting stream flow rate and reservoir storage needs.

```{r, fig.align="center", fig.cap= paste("Figure 1. Annual values over time. The gray line represents historical data modeled from ", past_data, ", the turquoise line represents ", model_bc, " ", model_bc_rcp, " ", "and the yellow line represents ", model_wc," ", model_wc_rcp, ".", sep = "")}



ggplot() +
  geom_line(data = annual_values, aes(x = year,
                                      y = annual_value,
                                      color = averages),
            size = 0.6) +
  facet_wrap(~variable, scales = "free") +
 scale_color_manual(name = "Annual Averages", values = c("gray60","#1496BB", "#EBC944"), labels = (c(paste(past_data), paste(model_bc, model_bc_rcp_name), paste(model_wc, model_wc_rcp_name)))) +
  theme(legend.title = element_blank(),
        axis.text.x = element_text(size = 8),
        axis.text.y = element_text(size = 8),
        plot.margin = margin(0, 0.5, 0, 0.5, "cm")) +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 4)) +
  labs(x ="",
       y = "Water (mm)")
  
if(save_images == TRUE){
ggsave(here::here("sites",
                  site, #site subfolder
                  "figures", #subfolder
                  paste("lat",lat,"lon",lon, sep = "_"),
                  "annual_facet.png")) #file name
}

```

\newpage

# Deficit v. Actual Evapotranspiration

Actual evapotranspiration (AET) is an estimate of soil water used by plants plus evaporation.  Deficit (D) is an estimate of unmet water need.  That is, it represents the amount of water vegetation would use if the water was available and hence is an estimate of vegetation drought stress.  Together, AET and D are good predictors of vegetation condition and are useful variables for understanding climate stress on vegetation and how vegetation may transition in the future (Stephenson, 1998). If the clustering of AET and D change in climate space, vegetation assemblages will respond and changes in assemblages will eventually reflect the new climate space. The figure below (Tercek et al., 2021) shows how AET v. D, calculated using the water balance model used for this report, differs across bioregions in the U.S.

```{r}
figure_lon_east = lon > -100

figure_lon_west = lon <= -100

```

```{r, echo=FALSE, out.width="45%", fig.cap="AET and Deficit climate space of vegetation ecoregions in the Western United states from  (Tercek et al., 2021).", fig.align="center", eval=figure_lon_east}

knitr::include_graphics(here::here("figures", "eastern_CONUS.png"))

```
```{r, echo=FALSE, out.width="45%", fig.cap="Figure 2. Ecoregions in the Western United states based on AET and Deficit (CWD). (Tercek et al., 2021)", fig.align="center", eval=figure_lon_west}

knitr::include_graphics(here::here("figures", "western_CONUS.png"))
```
<br>


```{r, fig.cap= "Figure 3. Modeled Deficit vs. AET. The points are annual sums of daily observations in each year. The green points represent 1980-2019; the yellow points 2020-2059; and the turquoise points 2060-2099. The contours around each set of points delineate shifts in climate space over time.", out.width = "50%", fig.show='hold'}

#----------
# Deficit v. AET
# ---------

# max x limit for the graph - to change dynamically

max_x_d_aet_1 <- annual_values %>% 
  filter(variable == "Deficit") 

max_x_d_aet_2 <- max(max_x_d_aet_1[,3], na.rm = TRUE)

max_x_d_aet <- max_x_d_aet_2*1.15

# max y limit for the graph - to change dynamically

max_y_d_aet_1 <- annual_values %>% 
filter(variable == "AET") 

max_y_d_aet_2 <- max(max_y_d_aet_1[,3], na.rm = TRUE)

max_y_d_aet <- max_y_d_aet_2*1.15


deficit_aet_bc <- bc_annual_values %>% 
  pivot_wider(names_from = variable,
              values_from = annual_value) %>% 
  clean_names()

deficit_aet_wc <- wc_annual_values %>% 
  pivot_wider(names_from = variable,
              values_from = annual_value) %>% 
  clean_names()

# ------------
# D v. AET best case
# ------------


ggplot(deficit_aet_bc) +
  geom_point(aes(x = deficit, y = aet, color = decades),
             size = 4,
             alpha = 0.6) +
  geom_encircle(aes(x = deficit, y = aet, color = decades),
                show.legend = FALSE,
                size = 2) +
  labs(title = paste("Deficit v. AET", "\n", model_bc, " ", model_bc_rcp_name, sep = ""),
       x = "Deficit",
       y = "AET") +
  scale_color_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                     values = c("#A3B86C", "#EBC944", "#1496BB")) +
  theme(legend.title = element_blank()) +
  ylim(NA, max_y_d_aet) +
  xlim(NA, max_x_d_aet) +
  theme(axis.title.x = element_text(size = 15))

if(save_images == TRUE){
ggsave(here::here("sites",
                  site, # site subfolder
                    "figures", #sub folder
                    paste("lat",lat,"lon",lon, sep = "_"),
                    paste("d_v_aet", model_bc_rcp, ".png", sep = "_"))) #file name)
}



# ------------
# D v. AET worst case
# ------------


ggplot(deficit_aet_wc) +
  geom_point(aes(x = deficit, y = aet, color = decades),
             size = 4,
             alpha = 0.6) +
  geom_encircle(aes(x = deficit, y = aet, color = decades),
                show.legend = FALSE,
                size = 2) +
  labs(title = paste("Deficit v. AET", "\n", model_wc, " ", model_wc_rcp_name, sep=""),
       x = "Deficit",
       y = "AET") +
  scale_color_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                     values = c("#A3B86C", "#EBC944", "#1496BB")) +
  theme(legend.title = element_blank()) +
  ylim(NA, max_y_d_aet) +
  xlim(NA, max_x_d_aet) +
  theme(axis.title.x = element_text(size = 15))

if(save_images == TRUE){
ggsave(here::here("sites",
                   site, # site subfolder
                    "figures", #sub folder
                    paste("lat",lat,"lon",lon, sep = "_"),
                    paste("d_v_aet", model_wc_rcp, ".png", sep = "_"))) #file name)
}

```
\newpage

# Water Balance Projections

## Soil Water

```{r, out.width="50%"}
plot_decades_smooth("soil_water_daily")
```
<br>
<br>



```{r, out.width="50%"}
plot_annual("Soil Water")
```
<br>
<br>


```{r, out.width="50%"}
plot_jitter("Soil Water")
```

\newpage

## Runoff

```{r, out.width="50%"}
plot_decades_smooth("runoff_daily")
```
<br>
<br>

```{r, out.width="50%"}
plot_annual("Runoff")
```
<br>
<br>

```{r, out.width="50%"}
plot_jitter("Runoff")
```

\newpage

## Rain

```{r, out.width="50%"}
plot_decades_smooth("rain_daily")
```
<br>
<br>

```{r, out.width="50%"}
plot_annual("Rain")
```
<br>
<br>

```{r, out.width="50%"}
plot_jitter("Rain")
```

\newpage

## Peak Snow Water Equivalent (SWE)

```{r, out.width="50%"}
plot_decades_smooth("accumswe_daily")
```


```{r, out.width="50%"}
plot_annual("Accumulated SWE")
```

<br>
<br>

```{r, out.width="50%"}
plot_jitter("Accumulated SWE")
```

\newpage

## Potential Evapotranspiration (PET)

```{r, out.width="50%"}
plot_decades_smooth("pet_daily")
```
<br>
<br>

```{r, out.width="50%"}
plot_annual("PET")
```
<br>
<br>

```{r, out.width="50%"}
plot_jitter("PET")
```

\newpage

## Actual Evapotranspiration (AET)

```{r, out.width="50%"}
plot_decades_smooth("aet_daily")
```
<br>
<br>

```{r, out.width="50%"}
plot_annual("AET")
```
<br>
<br>

```{r, out.width="50%"}
plot_jitter("AET")

```

\newpage

## Deficit

```{r, out.width="50%"}
plot_decades_smooth("deficit_daily")
```
<br>
<br>

```{r, out.width="50%"}
plot_annual("Deficit")
```
<br>
<br>

```{r, out.width="50%"}
plot_jitter("Deficit")
```


```{r}
## Accumulated Growing Degree Days

# remove this title from the code chunk when AGDD is put back into the report.
```

```{r, out.width="50%"}
# plot_decades_line("agdd_daily") - fix later, this data is bad - shouldn't plot 8-20-20
#plot_annual("AGDD")

```



\newpage

```{r, include=FALSE}

## Appendix

# To create the temperature v. precipitation scatterplot, go to the [MACA website](https://climate.northwestknowledge.net/MACA/vis_scatterplot.php), select "Mid 21st Century (2040-2069)" in the "Choose a Future Time Period:" box. The x-axis variable is "mean-temperature" and the season is "Jan-Dec." The y-axis is "Precipitation - Absolute Change" and the season is "Jan-Dec." Finally, enter the latitude `r lat` into BOTH latitude boxes and the longitude `r lon` into BOTH longitude boxes.
# 
# In order for the AET v. D graph to display, the `aet_d.Rmd` code must have been run and the models should have been selected for this report *prior* to running this final report.
# 
# <br>
# <br>

```



## Works Cited

Stephenson, N. (1998). Actual evapotranspiration and deficit: biologically meaningful correlates of vegetation distribution across spatial scales. Journal of biogeography, 25(5), 855-870.

Tercek, M., Thoma, D., Sherrill, K., Kagone, S., Senay, G., Gross, J. 2021 Historical changes in plant water use and need in the continental United States.  In review.
