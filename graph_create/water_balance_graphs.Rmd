---
author: "Janelle Christensen, Mike Tercek, David Thoma, John Gross"
date: "8/3/2020"
output: "html_document"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)


# ------------
# set variables for the data and code
# all of this should be changed before the code is run for a new site
# ------------

site = "Crystal_bench"
  
  #"quitobaquito" 
  
  #"little_saddle_mtn"

lat = 44.9051022
  
  # quito: 31.942809
  
  #lsm: 44.702

lon = -110.2873649


  #quito:-113.020708

  #lsm: -110.018

model_bc = "inmcm4" # "best case"

# model options: CCSM4, inmcm4, NorESM1-M, MRI-CGCM3, MIROC5, IPSL-CM5A-LR,  HadGEM2-CC365, GFDL-ESM2G, CanESM2, CSIRO-Mk3-6-0, CNRM-CM5, BNU-ESM

model_bc_rcp = "rcp45"

# options: "rcp45", "rcp85" 

model_bc_rcp_name = if(model_bc_rcp == "rcp45"){
  paste("RCP 4.5")
} else {
  paste("RCP 8.5")
} #automatically makes a more "readable" version of the rcp for graph titles and such


model_wc = "HadGEM2-CC365" # "worst case"

# model options: CCSM4, inmcm4, NorESM1-M, MRI-CGCM3, MIROC5, IPSL-CM5A-LR,  HadGEM2-CC365, GFDL-ESM2G, CanESM2, CSIRO-Mk3-6-0, CNRM-CM5, BNU-ESM

model_wc_rcp = "rcp85"

# options: "rcp45", "rcp85" 

model_wc_rcp_name = if(model_wc_rcp == "rcp45"){
  paste("RCP 4.5")
} else {
  paste("RCP 8.5")
} #automatically makes a more "readable" version of the rcp for graph titles and such


past_data = "gridMET"

# past_data options: "gridMET", "Daymet"
# if you want to use data that will work with the future models, gridMET is a better choice. It doesn't require adjusting for any biases

dry_year = 2012 # a particularly dry year, maybe with lots of fire activity? something for people to reference

wet_year = 2007 # particulary wet year for people to reference


# -------------
# attach packages
# -------------

if (!require("pacman")) install.packages("pacman")
pacman::p_load(remotes, data.table, here, tidyverse, beepr, lubridate, directlabels, data.table, ggbeeswarm, gghalves, directlabels, ggrepel, splines, magrittr, janitor, ggalt, ggrepel, sp, sf) 
#pacman package installs packages required to run the script
#the p_load function is for the packages that are a part of CRAN

pacman::p_load_gh("earthlab/cft")

library(data.table) 
library(here)
#library(plyr) 
# be careful with this, it causes issues for dplyr::group_by
# I didn't try, but the internet says if you load it before tidyverse, that issue goes away
library(tidyverse)
library(beepr)
library(lubridate)
library(directlabels)
library(data.table)
library(ggbeeswarm)
library(gghalves)
library(directlabels)
library(ggrepel)
library(splines)
library(magrittr)
library(janitor)
library(ggalt)
library(cft)
library(ggrepel)
library(sp)
library(sf)

```


```{r}

# ---------
# set up function to dynamically change title
# ---------

cap_str <- function(y) {
  c <- strsplit(y, "_")[[1]]
  paste(toupper(substring(c, 1,1)), substring(c, 2),
      sep="", collapse=" ")
}
# function taken from Dr. Arvind Singla 
# https://rstudio-pubs-static.s3.amazonaws.com/408658_512da947714740b99253228f084a08a9.html

title <- sapply(site, cap_str)

```

---
title: "Historical and Projected Water Balance Report for `r title`"
knit: (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(dirname(inputFile), "site.html")) })
---


```{r}

# -----------
# set global options
# -----------

#set theme for all graphs
theme_set(theme_classic() + #has the L shape around the graph
            theme(panel.grid = element_blank(), #removes grid lines
                  plot.title = element_text(size = 25), #title of plot text size
                  legend.text = element_text(size = 15), #legend inside text size
                  legend.title = element_text(size = 18), #legend title text size
                  axis.title.y = element_text(size = 15), #changes y axis lable text size
                  axis.title.x = element_blank(),#x axis text size
                  axis.text.x = element_text(size = 15), #changes x-axis text size
                  axis.text.y = element_text(size = 15), #changes y-axis text size
                  legend.position = "top"))  #location of legend

wrap_sentence <- function(string, width) {
  words <- unlist(strsplit(string, " "))
  fullsentence <- ""
  checklen <- ""
  for(i in 1:length(words)) {
    checklen <- paste(checklen, words[i])
    if(nchar(checklen)>(width+1)) {
      fullsentence <- paste0(fullsentence, "\n")
      checklen <- ""
    }
    fullsentence <- paste(fullsentence, words[i])
  }
  fullsentence <- sub("^\\s", "", fullsentence)
  fullsentence <- gsub("\n ", "\n", fullsentence)
  return(fullsentence)
}
#wrap_sentence function taken from https://stackoverflow.com/a/27734975/14061596


# ----------
# inmcm4, NorESM1-M downloaded wrong, don't use until updated (noted this 8-5-20)
# ----------

```


```{r, include=FALSE, eval=FALSE}
# Before running the remaining code, create subfolders as needed to save figures, only needs to be run once

#If you don't want to save the figures, then just comment out ggsave inside of the functions.

# create subfolders for figures

here::here(dir.create(paste("sites",
                            site))

here::here(dir.create(paste("sites",
                            site,
                            "figures",
                            sep = "/")))

here::here(dir.create(paste("sites",
                            site,
                            "figures",
                            paste("lat",lat,"lon",lon,sep = "_"), 
                            sep = "/")))

here::here(dir.create(paste("sites",
                            site,
                            "figures",
                            paste("lat",lat,"lon",lon,sep = "_"),
                            "40_yr_graphs",
                            sep = "/")))
```

```{r}
# -------------
# MONTHLY DATA
# clean data for graphing
# if monthly data wasn't downloaded, change {r} to {r, eval = FALSE } or else this will stop your code from running
# -------------

# I added a line of code that removes variables from the data set that sum to 2
# change this if needed

# -------------
# monthly future data
# -------------


future_month_1 <- read_csv(here::here("sites",
                                      site,
                                    "raw_data",
                                    paste("lat",lat,"lon",lon, sep = "_"),
                                    "future_monthly",
                                    paste(site, model_wc, model_wc_rcp, model_bc, model_bc_rcp, "monthly_future.csv", sep = "_")),
                    na = c("-3276.7")) 

date_fm <- future_month_1$date # this is a work around
# want to remove data that has all zeroes conditionally based on lat and lon
# couldn't get data to work to only remove data that had a sum of zero unless removed all non-variable columns

future_month <- future_month_1 %>% 
  select(-lat, -lon, -date) %>% #change this
  select(which(!colSums(., na.rm = TRUE) < 2)) %>% # this removes variable that sum to 2 (i.e. accumswe in a hot climate)
  mutate(date = date_fm,
         year = lubridate::year(date),
         month = lubridate::month(date,
                                  label = TRUE,
                                  abbr = TRUE))

# -------------
# monthly past
# -------------

# -------------
# Daymet cleaning
# -------------


# Daymet downloads date data wrong(all download as 1980), needing the code to be adjusted in the download
# this makes the dates formatted differently, so the data needs to be cleaned differently than gridMET

if(past_data == "Daymet"){ 
  past_month_1 <- read_csv(here::here("sites",
                                      site,
                                  "raw_data",
                                  paste("lat",lat,"lon",lon, sep = "_"),
                                  "historical_monthly",
                                  paste(site,"_monthly_",past_data,".csv",
                                        sep = "")),
                             na = c("-3276.7"))%>%  
    mutate(date = lubridate::ymd(paste(year,
                                     month,
                                     sep = "-"),
                               truncated = 1))#fix this when dates are fixed on site
# when/if dates download correctly for monthly historical, this line can be removed
# truncated needs to be here, can't say why it's 1
  
  date_pm <- past_month_1$date # this is a work around
# want to remove data that has all zeroes conditionally based on lat and lon
# couldn't get data to work to only remove data that had a sum of zero unless removed all non-variable columns

past_month <- past_month_1 %>%
  select(-lat, -lon, -month, - year, -date) %>%
  select(which(!colSums(., na.rm = TRUE) < 2)) %>% # this removes variable that sum to 2 (i.e. accumswe in a hot climate)
  mutate(date = date_pm, #adds date back into the df
         year = lubridate::year(date),
         month = lubridate::month(date,
                                  label = TRUE,
                                  abbr = TRUE))
} 

# ------------
# gridMET cleaning
# ------------

if(past_data == "gridMET"){ 
  past_month_1 <- read_csv(here::here("sites",
                                      site,
                                  "raw_data",
                                  paste("lat",lat,"lon",lon, sep = "_"),
                                  "historical_monthly",
                                  paste(site,"_monthly_",past_data,".csv", sep = "")),
                             na = c("-3276.7"))
  
  date_pm <- past_month_1$date # this is a work around
# want to remove data that has all zeroes conditionally based on lat and lon
# couldn't get data to work to only remove data that had a sum of zero unless removed all non-variable columns

past_month <- past_month_1 %>%
  select(-lat, -lon, -date) %>%
  select(which(!colSums(., na.rm = TRUE) < 2)) %>% # this removes variable that sum to 2 (i.e. accumswe in a hot climate)
  mutate(date = date_pm, #adds date back into the df
         year = lubridate::year(date),
         month = lubridate::month(date,
                                  label = TRUE,
                                  abbr = TRUE))
}


```

```{r}
# ------------
# DAILY DATA
# clean data for graphing
# ------------

# ------------
# daily future data
# ------------

future_day_1 <- read_csv(here::here("sites",
                                    site,
                                  "raw_data",
                                  paste("lat",lat,"lon",lon, sep = "_"),
                                  "future_daily",
                                  paste(site, model_wc, model_wc_rcp, model_bc, model_bc_rcp, "daily_future.csv", sep = "_")),
                    na = c("-3276.7"))

date_fd <- future_day_1$date
# this is a work around
# want to remove data that has all zeroes conditionally based on site
# couldn't get data to work to only remove data that had a sum of zero unless removed all non-variable columns


future_day <- future_day_1 %>% 
  select(-lat, -lon, -date) %>%
  #select(which(!colSums(., na.rm = TRUE) < 2)) %>% # this removes variable that sum to 2 (i.e. accumswe in a hot climate)
  mutate(date = date_fd,
    year = lubridate::year(date), 
    month = lubridate::month(date,
                             label = TRUE,
                             abbr = TRUE),
    day = lubridate::day(date),
    doy = yday(date))


# ------------
# daily past
# ------------

past_day_1 <- read_csv(here::here("sites",
                                      site,
                                  "raw_data",
                                  paste("lat",lat,"lon",lon, sep = "_"),
                                  "historical_daily",
                                  paste(site,"_daily_",past_data,".csv", sep = "")),
                           na = c("-3276.7")) 

date_pd <- past_day_1$date# this is a work around
# want to remove data that has all zeroes conditionally based on lat and lon
# couldn't get data to work to only remove data that had a sum of zero unless removed all non-variable columns

past_day <- past_day_1 %>% 
  select(-lat, -lon, -date)  %>%
  select(which(!colSums(., na.rm = TRUE) < 2)) %>% # this removes variables that sum to 2 (i.e. accumswe in a hot climate)
  mutate(date = date_pd,
         year = lubridate::year(date),
         month = lubridate::month(date,
                                  label = TRUE,
                                  abbr = TRUE),
         day = lubridate::day(date),
         doy = yday(date)) 


```

```{r, eval=FALSE}

# --------------------------------------------------------------------------------------
#
# DATA CLEANING
#
# -------------------------------------------------------------------------------------_


```


```{r}
# -------------
# Make site data into long format
# -------------

# -------------
# past data daily for summarizing by year
# -------------

annual_past <- past_day %>% 
  group_by(year) %>% 
  filter(!year == 2020) %>% 
  summarize(annual_soil_water = mean(soil_water_daily, na.rm = TRUE),
            annual_runoff = sum(runoff_daily, na.rm = TRUE), 
            annual_rain = sum(rain_daily, na.rm = TRUE),
            annual_accumswe = max(accumswe_daily, na.rm = TRUE),
            annual_pet = sum(pet_daily, na.rm = TRUE),
            annual_deficit = sum(deficit_daily, na.rm = TRUE), 
            #annual_agdd = max(agdd_daily, na.rm = TRUE), 
            #put this back in when agdd is working
            annual_aet = sum(aet_daily, na.rm = TRUE))


# -------------
# long format future data daily
# -------------

# -------------
# worst case
# -------------

wc_annual_future <- future_day %>%
  select(soil_water_daily_wc:aet_daily_wc, date:doy) %>% # selecting for variables for 8.5 only
  filter(!year == 2100) %>% 
  group_by(year) %>% 
    summarize(annual_soil_water_wc = mean(soil_water_daily_wc, na.rm = TRUE),
              annual_runoff_wc = sum(runoff_daily_wc, na.rm = TRUE),
              annual_rain_wc = sum(rain_daily_wc, na.rm = TRUE),
              annual_accumswe_wc = max(accumswe_daily_wc, na.rm = TRUE),
              annual_pet_wc = sum(pet_daily_wc, na.rm = TRUE),
              annual_deficit_wc = sum(deficit_daily_wc, na.rm = TRUE),
              #annual_agdd_wc = max(agdd_daily_wc, na.rm = TRUE), 
              #put this back in when agdd is working
              annual_aet_wc = sum(aet_daily_wc, na.rm = TRUE))
    
#-------------
# best case
# ------------
  
bc_annual_future <- future_day %>% 
  select(soil_water_daily_bc:aet_daily_bc, date:doy) %>% #selecting for 4.5 only
  filter(!year == 2100) %>% 
  group_by(year) %>% 
    summarize(annual_soil_water_bc = mean(soil_water_daily_bc, na.rm = TRUE),
              annual_runoff_bc = sum(runoff_daily_bc, na.rm = TRUE),
              annual_rain_bc = sum(rain_daily_bc, na.rm = TRUE),
              annual_accumswe_bc = max(accumswe_daily_bc, na.rm = TRUE),
              annual_deficit_bc = sum(deficit_daily_bc, na.rm = TRUE),
              annual_pet_bc = sum(pet_daily_bc, na.rm = TRUE),
              #annual_agdd_bc = max(agdd_daily_bc, na.rm = TRUE),
              #put this back in when agdd is working
              annual_aet_bc = sum(aet_daily_bc, na.rm = TRUE))

# -----------
# make values into one df
# -----------

# -----------
# best case
# ----------

bc_annual_values <- annual_past %>%
  full_join(bc_annual_future) %>% 
  pivot_longer(`annual_soil_water`:`annual_aet_bc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "annual_value") %>% 
  na.omit(annual_values) %>% # new column name to store values
  mutate(decade = case_when(
    .$year %in% c(1980:1989) ~ "1980s",
    .$year %in% c(1990:1999) ~ "1990s",
    .$year %in% c(2000:2009) ~ "2000s",
    .$year %in% c(2010:2019) ~ "2010s",
    .$year %in% c(2020:2029) ~ "2020s",
    .$year %in% c(2030:2039) ~ "2030s",
    .$year %in% c(2040:2049) ~ "2040s",
    .$year %in% c(2050:2059) ~ "2050s",
    .$year %in% c(2060:2069) ~ "2060s",
    .$year %in% c(2070:2079) ~ "2070s",
    .$year %in% c(2080:2089) ~ "2080s",
    TRUE ~ "2090s"
  ))  %>%  mutate(variable = case_when(
    .$variable %in% c("annual_runoff", "annual_runoff_bc") ~ "Runoff",
    #.Svariable calls the variable, then it can be renamed
    .$variable %in% c("annual_agdd", "annual_agdd_bc") ~ "AGDD",
    .$variable %in% c("annual_soil_water", "annual_soil_water_bc") ~ "Soil Water",
    .$variable %in% c("annual_rain", "annual_rain_bc") ~ "Rain",
    .$variable %in% c("annual_accumswe", "annual_accumswe_bc") ~ "Accumulated SWE",
    .$variable %in% c("annual_pet", "annual_pet_bc") ~ "PET",
    .$variable %in% c("annual_deficit", "annual_deficit_bc") ~ "Deficit",
    TRUE ~ "AET" # last ifelse is just labeled as TRUE
  )) %>% 
  mutate(averages = case_when(
    .$year %in% c(1980:2019) ~ "annual_avg",
    TRUE ~ "annual_avg_bc"
  )) %>% 
  mutate(decades = case_when( #don't need individual decades for this data
    .$year %in% c(1980:2019) ~ "1980-2019",
    .$year %in% c(2020:2059) ~ "2020-2059",
    TRUE ~ "2060-2099")) #decades by 39 yr chunks



# ------------
# worst case
# ------------

wc_annual_values <- annual_past %>% 
  full_join(wc_annual_future) %>%
  pivot_longer(`annual_soil_water`:`annual_aet_wc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "annual_value") %>% 
  na.omit(annual_values) %>% # new column name to store values
  mutate(decade = case_when(
    .$year %in% c(1980:1989) ~ "1980s",
    .$year %in% c(1990:1999) ~ "1990s",
    .$year %in% c(2000:2009) ~ "2000s",
    .$year %in% c(2010:2019) ~ "2010s",
    .$year %in% c(2020:2029) ~ "2020s",
    .$year %in% c(2030:2039) ~ "2030s",
    .$year %in% c(2040:2049) ~ "2040s",
    .$year %in% c(2050:2059) ~ "2050s",
    .$year %in% c(2060:2069) ~ "2060s",
    .$year %in% c(2070:2079) ~ "2070s",
    .$year %in% c(2080:2089) ~ "2080s",
    TRUE ~ "2090s" #decade individually
  )) %>% 
  mutate(variable = case_when( #make names more readable
    .$variable %in% c("annual_runoff", "annual_runoff_wc") ~ "Runoff",
    #.$variable calls the variable, then it can be renamed
    .$variable %in% c("annual_agdd", "annual_agdd_wc") ~ "AGDD",
    .$variable %in% c("annual_soil_water", "annual_soil_water_wc") ~ "Soil Water",
    .$variable %in% c("annual_rain", "annual_rain_wc") ~ "Rain",
    .$variable %in% c("annual_accumswe", "annual_accumswe_wc") ~ "Accumulated SWE",
    .$variable %in% c("annual_pet", "annual_pet_wc") ~ "PET",
    .$variable %in% c("annual_deficit", "annual_deficit_wc") ~ "Deficit",
    TRUE ~ "AET" # last ifelse is just labeled as TRUE
  ))  %>% 
  mutate(averages = case_when(
    .$year %in% c(1980:2019) ~ "annual_avg",
    TRUE ~ "annual_avg_wc"
  )) %>% 
  mutate(decades = case_when( #don't need individual decades for this data
    .$year %in% c(1980:2019) ~ "1980-2019",
    .$year %in% c(2020:2059) ~ "2020-2059",
    TRUE ~ "2060-2099")) #decades by 39 yr chunks

# ---------------
# all together now!
# ---------------

annual_values <- bc_annual_values %>% 
  full_join(wc_annual_values) 


```


```{r, include = FALSE, eval = FALSE}

# ------------
# Histograms and qq plots to look at data spread
# histogram for future data
# ------------

plot_histogram_past = function(.y) {
  .y_hist <- ggplot(data = annual_values %>%
                       filter(decade %in% c(.y))) +
    geom_histogram(aes(x = annual_value), binwidth = 10) +
    facet_wrap(~variable)+
    labs(title = paste(.y, model_bc_rcp_name))
  
  print(.y_hist)
}

plot_histogram = function(.y) {
  
.y_hist_bc <- ggplot(data = bc_annual_values %>%
                       filter(decade %in% c(.y))) +
    geom_histogram(aes(x = annual_value), binwidth = 10) +
    facet_wrap(~variable)+
    labs(title = paste(.y, model_bc_rcp_name))

.y_hist_wc <- ggplot(data = wc_annual_values %>%
                       filter(decade %in% c(.y))) +
    geom_histogram(aes(x = annual_value), binwidth = 10) +
    facet_wrap(~variable) +
    labs(title = paste(.y, model_wc_rcp_name))
  
  print(.y_hist_bc)
  print(.y_hist_wc)
}

# ------------
# histogram for past data
# ------------

plot_histogram_past("1980s")
plot_histogram_past("1990s")
plot_histogram_past("2000s")
plot_histogram_past("2010s")
plot_histogram("2020s")

# ------------
# histogram for future data
# ------------

plot_histogram("2030s")
plot_histogram("2040s")
plot_histogram("2050s")
plot_histogram("2060s")
plot_histogram("2070s")
plot_histogram("2080s")
plot_histogram("2090s")


# ---------
# qq plots of the data to look at data normalcy
# does it follow expected values?
# ---------

# ---------
# qq plots of future data
# ---------

plot_qq = function(.y) {
  
.y_qq_bc <- ggplot(data = bc_annual_values %>%
                     filter(decade %in% (.y))) +
    geom_qq(aes(sample = annual_value)) +
    facet_wrap(~variable, scales = "free")+
    labs(title = paste(.y, model_bc_rcp_name))

.y_qq_wc <- ggplot(data = wc_annual_values %>%
                     filter(decade %in% (.y))) +
    geom_qq(aes(sample = annual_value)) +
    facet_wrap(~variable, scales = "free")+
    labs(title = paste(.y, model_wc_rcp_name))
  
  print(.y_qq_bc)
  print(.y_qq_wc)
}

plot_qq("1980s")
plot_qq("1990s")
plot_qq("2000s")
plot_qq("2010s")
plot_qq("2020s")
plot_qq("2030s")
plot_qq("2040s")
plot_qq("2050s")
plot_qq("2060s")
plot_qq("2070s")
plot_qq("2080s")
plot_qq("2090s")

```


```{r}

## Data for graphs for 40 yr. period, shifts in timing of events

# --------
# clean data for 40 yr graphs
# graphs grouped by 40 yr chunks
# graphs then grouped by doy
# mean of doy taken, to be plotted on a single line that represents the mean of the doy for that 40 yr chunk
# --------

doy_avg_1980_2019 <-  past_day %>% 
  filter(year %in% c(1980:2019)) %>%
  pivot_longer(`soil_water_daily`:`aet_daily`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>%  # new column name to store values) 
#for grouping by doy
  group_by(doy, variable) %>% 
  summarize(`1980-2019` = mean(value, na.rm = TRUE),
            month = unique(month))

# --------
# Best case means
# --------

# 2020 - 2059 Best case
# first, rename variables to be able to combine them later

doy_avg_2020_2059_bc <- future_day %>% 
  filter(year %in% c(2020:2059)) %>%
  select(soil_water_daily_bc:doy) %>% 
  pivot_longer(`soil_water_daily_bc`:`aet_daily_bc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>% # new column name to store values)
  mutate(variable = case_when(.$variable == "aet_daily_bc" ~ "aet_daily",
    .$variable == "rain_daily_bc" ~ "rain_daily",
    .$variable == "runoff_daily_bc" ~ "runoff_daily",
    .$variable == "pet_daily_bc" ~ "pet_daily",
    .$variable == "accumswe_daily_bc" ~ "accumswe_daily",
    .$variable == "soil_water_daily_bc" ~ "soil_water_daily",
    .$variable == "agdd_daily_bc" ~ "agdd_daily",
    TRUE ~ "deficit_daily")) %>% 
  group_by(doy, variable) %>% 
  summarize(`2020-2059` = mean(value, na.rm = TRUE),
            month = unique(month)) 


# 2060 - 2099 Best case df
# first, rename variables to be able to combine them later

doy_avg_2060_2099_bc <-  future_day %>% 
  filter(year %in% c(2060:2099)) %>%
  select(soil_water_daily_bc:doy) %>%
  pivot_longer(`soil_water_daily_bc`:`aet_daily_bc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>%  # new column name to store values) 
  mutate(variable = case_when(.$variable == "aet_daily_bc" ~ "aet_daily",
    .$variable == "rain_daily_bc" ~ "rain_daily",
    .$variable == "runoff_daily_bc" ~ "runoff_daily",
    .$variable == "pet_daily_bc" ~ "pet_daily",
    .$variable == "accumswe_daily_bc" ~ "accumswe_daily",
    .$variable == "soil_water_daily_bc" ~ "soil_water_daily",
    .$variable == "agdd_daily_bc" ~ "agdd_daily",
    TRUE ~ "deficit_daily")) %>% #for grouping by doy
  group_by(doy, variable) %>% 
  summarize(`2060-2099` = mean(value, na.rm = TRUE),
            month = unique(month)) 

#full doy dataframe Best case

doy_avg_bc <- doy_avg_1980_2019 %>% 
  full_join(doy_avg_2020_2059_bc) %>% 
  full_join(doy_avg_2060_2099_bc) %>% 
  pivot_longer(c(`1980-2019`,`2020-2059`,`2060-2099`), # The columns I'm gathering together
               names_to = "decades", # new column name for existing names
               values_to = "value") %>% # new column name to store values 
  na.omit(doy_avg_bc) %>%  # because of the way the dataframe was made, there's NA's for second and third 40, just don't want those there
  pivot_wider(names_from = variable,
              values_from = value)


# --------
# wc means
# --------

# 2020 - 2059 wc df
# first, rename variables to be able to combine them later

doy_avg_2020_2059_wc <- future_day %>% 
  filter(year %in% c(2020:2059)) %>%
  select(soil_water_daily_wc:doy) %>% 
  pivot_longer(`soil_water_daily_wc`:`aet_daily_wc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>% # new column name to store values)
  mutate(variable = case_when(.$variable == "aet_daily_wc" ~ "aet_daily",
    .$variable == "rain_daily_wc" ~ "rain_daily",
    .$variable == "runoff_daily_wc" ~ "runoff_daily",
    .$variable == "pet_daily_wc" ~ "pet_daily",
    .$variable == "accumswe_daily_wc" ~ "accumswe_daily",
    .$variable == "soil_water_daily_wc" ~ "soil_water_daily",
    .$variable == "agdd_daily_wc" ~ "agdd_daily",
    TRUE ~ "deficit_daily")) %>% 
  group_by(doy, variable) %>% 
  summarize(`2020-2059` = mean(value, na.rm = TRUE),
            month = unique(month)) 


# 2060 - 2099 wc df
# first, rename variables to be able to combine them later

doy_avg_2060_2099_wc <-  future_day %>% 
  filter(year %in% c(2060:2099)) %>%
  select(soil_water_daily_wc:doy) %>%
  pivot_longer(`soil_water_daily_wc`:`aet_daily_wc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>%  # new column name to store values) 
  mutate(variable = case_when(.$variable == "aet_daily_wc" ~ "aet_daily",
    .$variable == "rain_daily_wc" ~ "rain_daily",
    .$variable == "runoff_daily_wc" ~ "runoff_daily",
    .$variable == "pet_daily_wc" ~ "pet_daily",
    .$variable == "accumswe_daily_wc" ~ "accumswe_daily",
    .$variable == "soil_water_daily_wc" ~ "soil_water_daily",
    .$variable == "agdd_daily_wc" ~ "agdd_daily",
    TRUE ~ "deficit_daily")) %>% 
  group_by(doy, variable) %>% 
  summarize(`2060-2099` = mean(value, na.rm = TRUE),
            month = unique(month)) 


#full day dataset wc

doy_avg_wc <- doy_avg_1980_2019 %>% 
  full_join(doy_avg_2020_2059_wc) %>% 
  full_join(doy_avg_2060_2099_wc) %>% 
  pivot_longer(c(`1980-2019`,`2020-2059`,`2060-2099`), # The columns I'm gathering together
               names_to = "decades", # new column name for existing names
               values_to = "value") %>% # new column name to store values 
  na.omit(doy_avg_wc) %>%  # because of the way the dataframe was made, there's NA's for second and third 40, just don't want those there
  pivot_wider(names_from = variable,
              values_from = value) 


```

```{r}
# ---------
# Month data made into a joined df
# used for the jitter plots
# ---------
month_join_1980_2019 <- past_month %>% 
  pivot_longer(`soil_water_monthly`:`aet_monthly`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>% # new column name to store values
  mutate(variable = case_when(
    .$variable == "runoff_monthly" ~ "Runoff",
    #.Svariable calls the variable, then it can be renamed
    .$variable == "agdd_monthly" ~ "AGDD",
    .$variable == "soil_water_monthly" ~ "Soil Water",
    .$variable == "rain_monthly" ~ "Rain",
    .$variable == "accumswe_monthly" ~ "Accumulated SWE",
    .$variable == "pet_monthly" ~ "PET",
    .$variable == "deficit_monthly" ~ "Deficit",
    TRUE ~ "AET" # last ifelse is just labeled as TRUE
  )) %>% 
  rename("1980-2019" = value)

# --------
# Best case month data in long format
# --------

# 2020 - 2059 Best case
# first, rename variables to be able to combine them later

month_join_2020_2059_bc <- future_month %>% 
  filter(year %in% c(2020:2059)) %>%
  select(soil_water_monthly_bc:month) %>% 
  pivot_longer(`soil_water_monthly_bc`:`aet_monthly_bc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>% # new column name to store values)
  mutate(variable = case_when(.$variable == "aet_monthly_bc" ~ "AET",
    .$variable == "rain_monthly_bc" ~ "Rain",
    .$variable == "runoff_monthly_bc" ~ "Runoff",
    .$variable == "pet_monthly_bc" ~ "PET",
    .$variable == "accumswe_monthly_bc" ~ "Accumulated SWE",
    .$variable == "soil_water_monthly_bc" ~ "Soil Water",
    .$variable == "agdd_monthly_bc" ~ "AGDD",
    TRUE ~ "Deficit")) %>% 
  rename("2020-2059" = value) 
  


# 2060 - 2099 Best case df
# first, rename variables to be able to combine them later

month_join_2060_2099_bc <-  future_month %>% 
  filter(year %in% c(2060:2099)) %>%
  select(soil_water_monthly_bc:month) %>%
  pivot_longer(`soil_water_monthly_bc`:`aet_monthly_bc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>%  # new column name to store values) 
  mutate(variable = case_when(.$variable == "aet_monthly_bc" ~ "AET",
    .$variable == "rain_monthly_bc" ~ "Rain",
    .$variable == "runoff_monthly_bc" ~ "Runoff",
    .$variable == "pet_monthly_bc" ~ "PET",
    .$variable == "accumswe_monthly_bc" ~ "Accumulated SWE",
    .$variable == "soil_water_monthly_bc" ~ "Soil Water",
    .$variable == "agdd_monthly_bc" ~ "AGDD",
    TRUE ~ "Deficit"))%>% 
  rename("2060-2099" = value) 

#full doy dataframe Best case

month_join_bc <- month_join_1980_2019 %>% 
  full_join(month_join_2020_2059_bc) %>% 
  full_join(month_join_2060_2099_bc) %>% 
  pivot_longer(`1980-2019`:`2060-2099`, # The columns I'm gathering together
               names_to = "decades", # new column name for existing names
               values_to = "value") %>% # new column name to store values 
  na.omit(month_join_bc_m)# because of the way the dataframe was made, there's NA's for second and third 40, just don't want those there


# --------
# wc
# --------

# 2020 - 2059 worst case
# first, rename variables to be able to combine them later

month_join_2020_2059_wc <- future_month %>% 
  filter(year %in% c(2020:2059)) %>%
  select(soil_water_monthly_wc:aet_monthly_wc, date:month) %>% 
  pivot_longer(`soil_water_monthly_wc`:`aet_monthly_wc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>% # new column name to store values)
  mutate(variable = case_when(.$variable == "aet_monthly_wc" ~ "AET",
    .$variable == "rain_monthly_wc" ~ "Rain",
    .$variable == "runoff_monthly_wc" ~ "Runoff",
    .$variable == "pet_monthly_wc" ~ "PET",
    .$variable == "accumswe_monthly_wc" ~ "Accumulated SWE",
    .$variable == "soil_water_monthly_wc" ~ "Soil Water",
    .$variable == "agdd_monthly_wc" ~ "AGDD",
    TRUE ~ "Deficit")) %>% 
  rename("2020-2059" = value) 


# 2060 - 2099 worst case df
# first, rename variables to be able to combine them later

month_join_2060_2099_wc <-  future_month %>% 
  filter(year %in% c(2060:2099)) %>%
  select(soil_water_monthly_wc:aet_monthly_wc, date:month) %>%
  pivot_longer(`soil_water_monthly_wc`:`aet_monthly_wc`, # The columns I'm gathering together
               names_to = "variable", # new column name for existing names
               values_to = "value") %>%  # new column name to store values) 
  mutate(variable = case_when(.$variable == "aet_monthly_wc" ~ "AET",
    .$variable == "rain_monthly_wc" ~ "Rain",
    .$variable == "runoff_monthly_wc" ~ "Runoff",
    .$variable == "pet_monthly_wc" ~ "PET",
    .$variable == "accumswe_monthly_wc" ~ "Accumulated SWE",
    .$variable == "soil_water_monthly_wc" ~ "Soil Water",
    .$variable == "agdd_monthly_wc" ~ "AGDD",
    TRUE ~ "Deficit"))%>% 
  rename("2060-2099" = value) 

#full doy dataframe worst case

month_join_wc <- month_join_1980_2019 %>% 
  full_join(month_join_2020_2059_wc) %>% 
  full_join(month_join_2060_2099_wc) %>% 
  pivot_longer(`1980-2019`:`2060-2099`, # The columns I'm gathering together
               names_to = "decades", # new column name for existing names
               values_to = "value") %>% # new column name to store values 
  na.omit(month_join_wc_m)# because of the way the dataframe was made, there's NA's for second and third 40, just don't want those there

```


```{r, eval=FALSE}

# -------------------------------------------------------------------------------------
#
# GRAPH FUNCTIONS
#
# -------------------------------------------------------------------------------------


```


```{r}
# -------
# Function for 40 yr chunks - smoothed line graph by doy
# -------


plot_decades_smooth = function(.y) { #start function
  
  max_y_1 <- doy_avg_bc %>%
    full_join(doy_avg_wc) %>%
  select(.y)


max_y_2 <- max(max_y_1[,2], na.rm = TRUE)

max_y <- max_y_2*1.15

  
  exists_.y <- exists(.y, where = doy_avg_bc) #check to see if the variable exists
  
  if(exists_.y == TRUE){ #start if statement Best case
  
  .y_plot_bc <- ggplot(doy_avg_bc) + 
    stat_smooth(size = 1.5,
                se = FALSE,
                aes(x = as.Date.numeric(doy, origin = "1980-01-01"),#allows for month on xaxis
                    y = .data[[.y]],
                    # calling my variable, which I'll name later in the command
                    group = decades,
                    color = decades),
                method = glm,
                family = quasipoisson,
                formula = y ~ ns(x, 16)) +
    theme(legend.title = element_blank())+
    #internet said to do this
    #quasipoisson is some type of statistical analysis type
    #forumula has something to do with the degrees of freedom
    #https://stackoverflow.com/questions/2777053/in-ggplot-restrict-y-to-be-0-in-loess
    # geom_vline(data = doy_avg_bc,
    #            xintercept = doy[.data[[.y]] == max(.data[[.y]])], color='red') +
    labs(color = "Year",
         y = ifelse(.y == "agdd_daily", "Growing Degree Days (C)", "Water (mm)"), 
         # R needs the "" here
         # the ifelse goes after the command you want to change
         #.y is useful because it prevents R from confusing it with something else
         # purrr is much more useful than a for loop here
         # if {} else{} and if_else() both didn't work, but I don't know why
         title = case_when(.y ==  "soil_water_daily" ~ 
                             wrap_sentence(paste("Soil Water Seasonality",
                                   model_bc, model_bc_rcp_name), 30), #title based on variable
                           .y == "runoff_daily" ~ 
                             wrap_sentence(paste("Runoff Seasonality",
                                   model_bc, model_bc_rcp_name), 30),
                           .y == "rain_daily" ~  
                             wrap_sentence(paste("Rain Seasonality",
                                   model_bc, model_bc_rcp_name), 30),
                           .y == "agdd_daily" ~ 
                             wrap_sentence(paste("AGDD Seasonality",
                                   model_bc,model_bc_rcp_name), 30),
                           .y == "accumswe_daily"~ 
                            wrap_sentence(paste(
                              "Accumulated SWE Seasonality",
                                   model_bc,model_bc_rcp_name), 30),
                           .y == "pet_daily" ~ 
                             wrap_sentence(paste(
                               "Potential Evapotranspiration Seasonality",
                               model_bc,model_bc_rcp_name), 30),
                           .y == "deficit_daily" ~ 
                             wrap_sentence(paste("Deficit Seasonality",
                                   model_bc, model_bc_rcp_name), 30),
                           TRUE ~ 
                             wrap_sentence(paste(
                               "Actual Evapotranspiration Seasonality",
                                   model_bc, model_bc_rcp_name), 30))) + 
    scale_color_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                       values = c("#A3B86C", "#EBC944", "#1496BB")) +
    ylim(0, max_y) +
    scale_x_date(as.Date.numeric(doy_avg_bc$doy, origin = "1980-01-01"),
                 breaks = seq(as.Date("1980-01-15"), 
                            as.Date("1980-12-15"),#plots dates midmonth
                            by = "1 month"),
                 date_labels = "%b")#%b is abbreviated %B is full month name
    
gb <- ggplot_build(.y_plot_bc)

  vline_data_bc <- 
    gb$data[[1]] %>% 
    group_by(group) %>% 
    summarize(xintercept = x[which(y == max(y))])
 
  .y_plot_bc <- .y_plot_bc + geom_vline(aes(xintercept = xintercept), data = vline_data_bc)
  
  
  ggsave(here::here("sites",
                    site, # site subfolder
                    "figures", #sub folder
                    paste("lat",lat,"lon",lon, sep = "_"),
                    "40_yr_graphs", # subfolder
                    paste(.y, "40_yr", model_bc_rcp, ".png", sep = "_"))) #file name
  # 
  print(.y_plot_bc)
  
  } #end if statement for Best case
  
  exists_.y <- exists(.y, where = doy_avg_wc) #check to see if the variable exists
  
  if(exists_.y == TRUE){ #start if statement RCP 8.5
  
  .y_plot_wc <- ggplot(doy_avg_wc) +
    stat_smooth(size = 1.5,
                se = FALSE,
                aes(x = as.Date.numeric(doy, origin = "1980-01-01"),#allows for month on xaxis
                    y = .data[[.y]],
                    # calling my variable, which I'll name later in the command
                    group = decades,
                    color = decades),
                method = glm,
                family = quasipoisson,
                formula = y ~ ns(x, 16)) +
    theme(legend.title = element_blank()) +
        #internet said to do this
    #quasipoisson is some type of statistical analysis type
    #forumula has something to do with the degrees of freedom
    #https://stackoverflow.com/questions/2777053/in-ggplot-restrict-y-to-be-0-in-loess
    #geom_vline(xintercept = doy[.data[[.y]] == max(.data[[.y]])],color='red') +
    labs(color = "Year",
         y = ifelse(.y == "agdd_daily", "Growing Degree Days (C)", "Water (mm)"), 
         # R needs the "" here
         # the ifelse goes after the command you want to change
         #.y is useful because it prevents R from confusing it with something else
         # purrr is much more useful than a for loop here
         # if {} else{} and if_else() both didn't work, but I don't know why
         title = case_when(.y ==  "soil_water_daily" ~ 
                             wrap_sentence(paste("Soil Water Seasonality",
                                   model_wc, model_wc_rcp_name), 30), #title based on variable
                           .y == "runoff_daily" ~ 
                             wrap_sentence(paste("Runoff Seasonality",
                                   model_wc, model_wc_rcp_name), 30),
                           .y == "rain_daily" ~  
                             wrap_sentence(paste("Rain Seasonality",
                                   model_wc, model_wc_rcp_name), 30),
                           .y == "agdd_daily" ~ 
                             wrap_sentence(paste("AGDD Seasonality",
                                   model_wc,model_wc_rcp_name), 30),
                           .y == "accumswe_daily"~ 
                            wrap_sentence(paste(
                              "Accumulated SWE Seasonality",
                                   model_wc,model_wc_rcp_name), 30),
                           .y == "pet_daily" ~ 
                             wrap_sentence(paste(
                               "Potential Evapotranspiration Seasonality",
                               model_wc,model_wc_rcp_name), 30),
                           .y == "deficit_daily" ~ 
                             wrap_sentence(paste("Deficit Seasonality",
                                   model_wc, model_wc_rcp_name), 30),
                           TRUE ~ 
                             wrap_sentence(paste(
                               "Actual Evapotranspiration Seasonality",
                                   model_wc, model_wc_rcp_name), 30))) +
    scale_color_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                       values = c("#A3B86C", "#EBC944", "#1496BB")) +
  ylim(0, max_y)+
    scale_x_date(as.Date.numeric(doy_avg_bc$doy, origin = "1980-01-01"),
                 breaks = seq(as.Date("1980-01-15"), 
                            as.Date("1980-12-15"), #plots date at midmonth
                            by = "1 month"),
                 date_labels = "%b")#%b is abbreviated, %B is full month name
  gb <- ggplot_build(.y_plot_bc)

  vline_data_wc <- 
    gb$data[[1]] %>% 
    group_by(group) %>% 
    summarize(xintercept = x[which(y == max(y))])
 
  .y_plot_wc <- .y_plot_wc + geom_vline(aes(xintercept = xintercept), data = vline_data_wc)
  
  ggsave(here::here("sites",
                    site, #site subfolder
                    "figures", #top folder
                    paste("lat",lat,"lon",lon, sep = "_"),
                    "40_yr_graphs", # subfolder
                    paste(.y, "40_yr", model_wc_rcp, ".png", sep = "_"))) #file name
  
  print(.y_plot_wc)
  
  } #end if statement worst case

  
} #end function decades_smooth



# ---------
# function for line graph
# ---------



plot_decades_line = function(.y) { #start function
  
  max_y_1 <- doy_avg_bc %>%
    full_join(doy_avg_wc) %>%
  select(.y)


max_y_2 <- max(max_y_1[,2], na.rm = TRUE)

max_y <- max_y_2*1.15
  
  exists_.y <- exists(.y, where = doy_avg_bc) #check to see if the variable exists
  
  if(exists_.y == TRUE){ #start if statement Best case

.y_plot_bc <- ggplot(doy_avg_bc) + 
    geom_line(size = 1.5,
                aes(x = as.Date.numeric(doy, origin = "1980-01-01"),#plots month on x axis
                    y = .data[[.y]],
                    # calling my variable, which I'll name later in the command
                    group = decades,
                    color = decades)) +
  theme(legend.title = element_blank()) +
    #internet said to do this
    #quasipoisson is some type of statistical analysis type
    #forumula has something to do with the degrees of freedom
    #https://stackoverflow.com/questions/2777053/in-ggplot-restrict-y-to-be-0-in-loess
    # geom_vline(data = doy_avg_bc,
    #            xintercept = doy[.data[[.y]] == max(.data[[.y]])], color='red') +
    labs(color = "Year",
         y = ifelse(.y == "agdd_daily", "Growing Degree Days (C)", "Water (mm)"), 
         # R needs the "" here
         # the ifelse goes after the command you want to change
         #.y is useful because it prevents R from confusing it with something else
         # purrr is much more useful than a for loop here
         # if {} else{} and if_else() both didn't work, but I don't know why
         title = case_when(.y ==  "soil_water_daily" ~ 
                             wrap_sentence(paste("Soil Water Seasonality",
                                   model_bc, model_bc_rcp_name), 30), #title based on variable
                           .y == "runoff_daily" ~ 
                             wrap_sentence(paste("Runoff Seasonality",
                                   model_bc, model_bc_rcp_name), 30),
                           .y == "rain_daily" ~  
                             wrap_sentence(paste("Rain Seasonality",
                                   model_bc, model_bc_rcp_name), 30),
                           .y == "agdd_daily" ~ 
                             wrap_sentence(paste("AGDD Seasonality",
                                   model_bc,model_bc_rcp_name), 30),
                           .y == "accumswe_daily"~ 
                            wrap_sentence(paste(
                              "Accumulated SWE Seasonality",
                                   model_bc,model_bc_rcp_name), 30),
                           .y == "pet_daily" ~ 
                             wrap_sentence(paste(
                               "Potential Evapotranspiration Seasonality",
                               model_bc,model_bc_rcp_name), 30),
                           .y == "deficit_daily" ~ 
                             wrap_sentence(paste("Deficit Seasonality",
                                   model_bc, model_bc_rcp_name), 30),
                           TRUE ~ 
                             wrap_sentence(paste(
                               "Actual Evapotranspiration Seasonality",
                                   model_bc, model_bc_rcp_name), 30))) +
    scale_color_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                       values = c("#A3B86C", "#EBC944", "#1496BB")) +
  ylim(NA, max_y) +
    scale_x_date(as.Date.numeric(doy_avg_bc$doy, origin = "1980-01-01"),
                 breaks = seq(as.Date("1980-01-15"), 
                            as.Date("1980-12-15"),#moves breaks to midmonth
                            by = "1 month"),
                 date_labels = "%b")# %b gives abbreviated %B gives full month name
  
  ggsave(here::here("sites",
                    site, # site subfolder
                    "figures", #sub folder
                    paste("lat",lat,"lon",lon, sep = "_"),
                    "40_yr_graphs", # subfolder
                    paste(.y, "40_yr_line",model_bc_rcp, ".png", sep = "_"))) #file name
  print(.y_plot_bc)
  
  } # end if statement rcp bc
  
  exists_.y <- exists(.y, where = doy_avg_wc) #check to see if the variable exists
  
  if(exists_.y == TRUE){ #start if statement best case
  
  .y_plot_wc <- ggplot(doy_avg_wc) +
    geom_line(size = 1.5,
                aes(x = as.Date.numeric(doy, origin = "1980-01-01"),#allows months to plot on x axis
                    y = .data[[.y]],
                    # calling my variable, which I'll name later in the command
                    group = decades,
                    color = decades)) +
    theme(legend.title = element_blank()) +
    labs(color = "Year",
         y = ifelse(.y == "agdd_daily", "Growing Degree Days (C)", "Water (mm)"), 
         # R needs the "" here
         # the ifelse or case_when goes after the command you want to change
         #.y is useful because it prevents R from confusing it with something else
         title = case_when(.y ==  "soil_water_daily" ~ 
                             wrap_sentence(paste("Soil Water Seasonality",
                                   model_wc, model_wc_rcp_name), 30), #title based on variable
                           .y == "runoff_daily" ~ 
                             wrap_sentence(paste("Runoff Seasonality",
                                   model_wc, model_wc_rcp_name), 30),
                           .y == "rain_daily" ~  
                             wrap_sentence(paste("Rain Seasonality",
                                   model_wc, model_wc_rcp_name), 30),
                           .y == "agdd_daily" ~ 
                             wrap_sentence(paste("AGDD Seasonality",
                                   model_wc,model_wc_rcp_name), 30),
                           .y == "accumswe_daily"~ 
                            wrap_sentence(paste(
                              "Accumulated SWE Seasonality",
                                   model_wc,model_wc_rcp_name), 30),
                           .y == "pet_daily" ~ 
                             wrap_sentence(paste(
                               "Potential Evapotranspiration Seasonality",
                               model_wc,model_wc_rcp_name), 30),
                           .y == "deficit_daily" ~ 
                             wrap_sentence(paste("Deficit Seasonality",
                                   model_wc, model_wc_rcp_name), 30),
                           TRUE ~ 
                             wrap_sentence(paste(
                               "Actual Evapotranspiration Seasonality",
                                   model_wc, model_wc_rcp_name), 30))) +
    scale_color_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                       values = c("#A3B86C", #turquoise
                                  "#EBC944", #green
                                  "#1496BB")) +#yellow
    ylim(NA, max_y) +
    scale_x_date(as.Date.numeric(doy_avg_bc$doy, origin = "1980-01-01"),
                 breaks = seq(as.Date("1980-01-15"), 
                            as.Date("1980-12-15"),#sets labels at the middle of the month
                            by = "1 month"),
                 date_labels = "%b")
  
  ggsave(here::here("sites",
                    site, #site subfolder
                    "figures", #top folder
                    paste("lat",lat,"lon",lon, sep = "_"),
                    "40_yr_graphs", # subfolder
                    paste(.y, "40_yr_line",model_wc_rcp, ".png", sep = "_"))) #file name
  
  print(.y_plot_wc)
  
  } #end if statement RCP 8.5
  
  
  
} #end function decades_line

# call graphs later



  
```


```{r, out.width="50%"}
## Individual Graphs of change over time

plot_annual = function(.y) {
   
   point_low <- annual_values %>%
     filter(variable %in% c(.y)) %>% 
     filter(year == dry_year)
   
   point_high<- annual_values %>%
     filter(variable %in% c(.y)) %>% 
     filter(year == wet_year)
   
   line_low <- point_low$annual_value
   
   line_high <- point_high$annual_value
   
   # ---------------
   # create y limit for graph
   # ---------------
   
    max_y_1 <- annual_values %>%
      filter(variable %in% c(.y))
    
    max_y_2 <- max(max_y_1[,3], na.rm = TRUE)
    
    max_y <- max_y_2*1.15
    
    # ---------------
    # graph
    # ---------------
  
  annual_graph_bc <- ggplot() +
    geom_line(data = annual_values %>% 
                filter(averages %in% c("annual_avg", "annual_avg_bc")) %>% 
                filter(variable == .y), # filter data for historical and bc lines
              aes(x = year, 
                  y = annual_value, 
                  color = averages),
              size = .75) +
    geom_hline(data = point_low, # draws a line at a dry year
               yintercept = line_low, 
               linetype = "dashed",
               color = "#DA621E") +
    geom_hline(data = point_high, # draws a line at a wet year
               yintercept = line_high, 
               linetype = "dashed",
               color = "#1287A8") +
    geom_point(data = point_low, # highlights a dry year point
               aes(x = year, y = annual_value),
               color = "#DA621E",
               alpha =  0.25,
               size = 4) +
    geom_point(data = point_high, # highlights a dry year point
               aes(x = year, y = annual_value),
               color = "#1287A8",
               alpha =  0.25,
               size = 4) +
  labs(title = wrap_sentence(paste("Annual", .y, model_bc, model_bc_rcp_name),30),
       y = ifelse(.y == "agdd_daily", "Growing Degree Days (C)",
                    "Water (mm)")) +
      geom_text(data = point_low, # labels the line
              aes(x = 1973, 
                  y = annual_value,
                  label = year, 
                  vjust = -0.35), # -0.x moves the text up above the line
              color = "#DA621E") +
    geom_text(data = point_high, # labels the line
              aes(x = 1973, 
                  y = annual_value,
                  label = year, 
                  vjust = -0.35), # -0.x moves the text up above the line
              color = "#1287A8") +
    scale_color_manual(name = "", values = c("gray60","#A3B86C"), labels = (c(paste(past_data), paste(model_bc, model_bc_rcp_name)))) + # colors is a named vector, see top of function
 ylim(NA, max_y)
  
  ggsave(here::here("sites",
                    site, #site subfolder
                    "figures", #subfolder
                    paste("lat",lat,"lon",lon,sep = "_"),
                    paste(.y, "annual_graph_bc.png", sep = "_"))) #file name
  
  
  annual_graph_wc <- ggplot() +
    geom_line(data = annual_values %>% 
                filter(averages %in% c("annual_avg", "annual_avg_wc")) %>%
                filter(variable == .y), # filter data for historical and wc lines
              aes(x = year, 
                  y = annual_value, 
                  color = averages),
              size = .75) +
    geom_hline(data = point_low, 
               yintercept = line_low, 
               linetype = "dashed",
               color = "#DA621E") +
    geom_hline(data = point_high, # draws a line at a wet year
               yintercept = line_high, 
               linetype = "dashed",
               color = "#1287A8") +
    geom_point(data = point_low, # highlights a dry year point
               aes(x = year, y = annual_value),
               color = "#DA621E",
               alpha =  0.25,
               size = 4) +
    geom_point(data = point_high, # highlights a dry year point
               aes(x = year, y = annual_value),
               color = "#1287A8",
               alpha =  0.25,
               size = 4) +
  labs(title = wrap_sentence(paste("Annual",.y, model_wc, model_wc_rcp_name), 30),
       y = ifelse(.y == "ADGG", "Growing Degree Days (C)",
                    "Water (mm)")) +
    geom_text(data = point_low,
              aes(x = 1973, 
                  y = annual_value,
                  label = year, 
                  vjust = -0.35),
              color = "#DA621E") +
    geom_text(data = point_high, # labels the line
              aes(x = 1973, 
                  y = annual_value,
                  label = year, 
                  vjust = -0.35), # -0.x moves the text up above the line
              color = "#1287A8") +
    scale_color_manual(name = "", values = c("gray60", "#EBC944"), labels = (c(paste(past_data), paste(model_wc, model_wc_rcp_name)))) + # colors is a named vector, see top of function
  ylim(NA, max_y)
  
  ggsave(here::here("sites",
                    site, #site subfolder
                    "figures", #subfolder
                    paste("lat",lat,"lon",lon, sep = "_"),
                    paste(.y, "annual_graph_wc.png", sep = "_"))) #filename
  
  # return(annual_graph_bc)
  # return(annual_graph_wc) with these two it only prints the 4.5 graph
  
  print(annual_graph_bc)
  print(annual_graph_wc)
  
}

```

```{r}

# --------
# jitter under boxplot
# --------

plot_jitter <- function(.y){
  
   max_y_1 <- month_join_bc %>%
     full_join(month_join_wc) %>% 
      filter(variable %in% c(.y))
    
    max_y_2 <- max(max_y_1[,6], na.rm = TRUE) #calling the values column, number 6
    
    max_y <- max_y_2*1.15
# ---------
# jitter best case
# ---------

dodge <- position_dodge(width = 1)

jitter_bc <- ggplot(data =  month_join_bc %>%
         filter(variable %in% c(.y)),
       aes(x = decades, 
           y = value, 
           shape = NULL)) + #originally had "group = decade" here
                            # this caused the facet_wrap to include all variables on all facets
  geom_jitter(aes(colour = decades),
             size = 3,
             alpha = 0.25) + # dodge is a written code (see above)
  geom_boxplot(aes(x = decades, # internet had "mapping =" in front of
                   # aes, removed and nothing changed
                   y = value),
               alpha = 0.3,
               nudge = 0.025,
               outlier.shape = NA,#hides outliers
               #position = dodge, # has to match the other half
               fill = "grey60") +
  scale_color_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                     values = c("#A3B86C", "#EBC944", "#1496BB")) +
  scale_fill_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                     values = c("#A3B86C", "#EBC944", "DA621E")) +
  labs(y = "Water(mm)",
       title = wrap_sentence(paste(.y, model_bc, model_bc_rcp_name), 30)) +
  guides(color = guide_legend(override.aes = list(size=5, #changes size of legend dots
                                                  alpha = 0.5)))+
  theme(legend.title = element_blank()) +
  ylim(NA, max_y)

ggsave(here::here("sites",
                  site, #site subfolder
                  "figures", #subfolder
                  paste("lat",lat,"lon",lon, sep = "_"),
                  paste("jitter_bc_",.y,".png", sep = ""))) # file name

# ----------
# Jitter worst case
# ----------


jitter_wc <- ggplot(data =  month_join_wc %>%
         filter(variable %in% c(.y)),
       aes(x = decades, 
           y = value, 
           shape = NULL)) + #originally had "group = decade" here
                            # this caused the facet_wrap to include all variables on all facets
  geom_jitter(aes(colour = decades),
             size = 3,
             alpha = 0.25) + # dodge is a written code (see above)
  geom_boxplot(aes(x = decades, # internet had "mapping =" in front of
                   # aes, removed and nothing changed
                   y = value),
               alpha = 0.3,
               nudge = 0.025,
               outlier.shape = NA,#hides outliers
               #position = dodge, # has to match the other half
               fill = "grey60") +
  scale_color_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                     values = c("#A3B86C", "#EBC944", "#1496BB")) +
  scale_fill_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                     values = c("#A3B86C", "#EBC944", "#1496BB")) +
  labs(y = "Water(mm)",
       title = wrap_sentence(paste(.y, model_wc, model_wc_rcp_name), 30)) +
  guides(color = guide_legend(override.aes = list(size=5,
                                                  alpha = 0.5)))+
  theme(legend.title = element_blank()) +
  ylim(NA, max_y)

ggsave(here::here("sites",
                  site, #site subfolder
                  "figures", #subfolder
                  paste("lat",lat,"lon",lon, sep = "_"),
                  paste("jitter_wc_", .y,".png", sep = "_"))) # file name

print(jitter_bc)
print(jitter_wc)
}


```


```{r}

# --------------------------------------------------------------------------------------
#
# BEGIN OF ACTUAL REPORT
#
# --------------------------------------------------------------------------------------

```

Water balance is the mathematical accounting of water input and movement through the environment.  It accounts for water storage in different phases (ice, liquid) and loss to the atmosphere (gas) via evapotranspiration.  Water balance integrates the interactions of temperature and precipitation to estimate water availability, movement to streams and ground water and use by plants. Water balance accounts for heat load on different aspects and water holding capacity of different soil types. Water balance represents the modification of regional weather and climate to represent the biophysical conditions at local scales.  For these reasons, water balance is usually more strongly correlated with natural resource response (plant growth, stream flow, fire danger) than temperature or precipitation.

```{r, echo=FALSE, out.width="60%", fig.align="center"}

knitr::include_graphics(here::here("figures","mccabe_and_markstrom.png"))

```
```{r, results="hide"}

website <- ifelse(past_data == "gridMET", print("[gridMET](http://www.climatologylab.org/gridmet.html)"), print("[Daymet](https://daymet.ornl.gov/)"))

```

This report is created from temperature and precipitation data that is input to a water balance model.  The historical temperature and precipitation data are from `r website`. The future climate projections, `r model_bc` `r model_bc_rcp_name` and `r model_wc` `r model_wc_rcp_name`, are from the [CMIP5 experiments](https://www.wcrp-climate.org/wgcm-cmip/wgcm-cmip5) .  The water balance model is maintained by the National Park Service (Mike Tercek, David Thoma and John Gross).  Collectively this report summarizes historical and projected biophysical environmental conditions from 1980-2100 at the single grid cell level (`r past_data` = 4km; projections = 1km).   A link to the NPS water balance gridded products an be found [here](http://www.yellowstone.solutions/thredds/catalog.html).

## Selection of the Models

The models used in this analysis were chosen based upon which two climate futures best bracket the range of possibilities. For this region, the potentials are shown in the graph below.
```{r, echo=FALSE, out.width="80%", fig.align="center", eval=FALSE}

x <- "DeltaTavg"
y <- "DeltaPr"

knitr::include_graphics(here::here("sites",
                                   site, "figures", paste("lat_", lat, "_lon_", lon, sep = ""), paste(site, "Scatter BY SCENARIO-",x,"--",y,".png",sep="")))
```


## Annual values through time

The variables of runoff, rain, potential evapotranspiration (PET), actual evapotranspiration (AET), and deficit are summed to show annual values through time. Accumulated snow water equivalent (SWE) shows the max value for the year regardless of the month it occurs in. Accumulated growing degree days (AGDD) starts accumulating on October 1 of the previous year, and the max value is taken at its highest point. Soil water shows the mean value for the year.

The reason for the different summary statistics is because hydrologist use these variables in different ways.  Water variables that don’t have an upper limit like rain, runoff, evapostranspiration and deficit can accumulate indefinitely within a calendar year, whereas soil moisture is limited by the soil water holding capacity so it is averaged on an annual basis.  Temperature variables are averaged by convention and growing degree days are summed to account for the seasonal accumulation of heat that controls biological metabolism and thus growth rates and phenology when water is available. For the variables that are accumulated, we take the max of the variable because it is already a summation of the total through the year. 

```{r, fig.align="center", fig.cap= paste("Figure 1. Annual averages over time. The gray line represents historical data modeled from", past_data, "climate data, the turquoise line represents", model_bc, model_bc_rcp, "and the yellow line represents", model_wc, model_wc_rcp)}



ggplot() +
  geom_line(data = annual_values, aes(x = year,
                                      y = annual_value,
                                      color = averages),
            size = 0.6) +
  facet_wrap(~variable, scales = "free") +
 scale_color_manual(name = "Annual Averages", values = c("gray60","#1496BB", "#EBC944"), labels = (c(paste(past_data), paste(model_bc, model_bc_rcp_name), paste(model_wc, model_wc_rcp_name)))) +
  theme(legend.title = element_blank(),
        axis.text.x = element_text(size = 8),
        axis.text.y = element_text(size = 8),
        plot.margin = margin(0, 0.5, 0, 0.5, "cm")) +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 4)) +
  labs(x ="",
       y = "Water (mm)")
  

ggsave(here::here("sites",
                  site, #site subfolder
                  "figures", #subfolder
                  paste("lat",lat,"lon",lon, sep = "_"),
                  "annual_facet.png")) #file name

```

## Deficit v. Actual Evapotranspiration (AET)

Deficit (D) and actual evapotranspiration (AET) represent unmet water needs of vegetation and vegetation water use.  They are good predictors of vegetation type, and are useful variables in understanding climate stress on vegetation and how vegetation may transition in the future (Stephenson, 1998). If the clustering of AET and deficit change in climate space, vegetation assemblages will respond and changes in assemblages will eventually reflect the new climate space. The figure below (from Stephenson) shows how AET v. D differs across bioregions in the U.S. 
```{r, echo=FALSE, out.width="50%", fig.cap="Figure 2. Stephenson (1998)", fig.align="center"}

knitr::include_graphics(here::here("figures", "aet_v_d.gif"))

```


```{r, out.width="50%", fig.cap= paste("Figure 3. Modeled Deficit vs. AET. The points are annual sums of daily observations in each year. The green points represent 1980-2019; the yellow points 2020-2059; and the turquoise points 2060-2099. The contours around each set of points encircle the climate space for ", model_bc, " ", model_bc_rcp, " and ", model_wc, " ", model_wc_rcp, ".", sep = ""), fig.show="hold"}

#----------
# Deficit v. AET
# ---------

# max y limit for the graph - to change dynamically
max_y_d_aet_1 <- annual_values %>% 
filter(variable == "Deficit") 

max_y_d_aet_2 <- max(max_y_d_aet_1[,3], na.rm = TRUE)

max_y_d_aet <- max_y_d_aet_2*1.15

# max x limit for the graph - to change dynamically

max_x_d_aet_1 <- annual_values %>% 
  filter(variable == "AET") 

max_x_d_aet_2 <- max(max_x_d_aet_1[,3], na.rm = TRUE)

max_x_d_aet <- max_x_d_aet_2*1.15

deficit_aet_bc <- bc_annual_values %>% 
  pivot_wider(names_from = variable,
              values_from = annual_value) %>% 
  clean_names()

deficit_aet_wc <- wc_annual_values %>% 
  pivot_wider(names_from = variable,
              values_from = annual_value) %>% 
  clean_names()

# ------------
# D v. AET best case
# ------------


ggplot(deficit_aet_bc) +
  geom_point(aes(x = deficit, y = aet, color = decades),
             size = 4,
             alpha = 0.6) +
  geom_encircle(aes(x = deficit, y = aet, color = decades),
                show.legend = FALSE,
                size = 2) +
  labs(title = wrap_sentence(paste("Deficit v. AET", model_bc, model_bc_rcp_name), 30),
       x = "Deficit",
       y = "AET") +
  scale_color_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                     values = c("#A3B86C", "#EBC944", "#1496BB")) +
  theme(legend.title = element_blank()) +
  ylim(NA, max_y_d_aet) +
  xlim(NA, max_x_d_aet) +
  theme(axis.title.x = element_text(size = 15))

ggsave(here::here("sites",
                  site, # site subfolder
                    "figures", #sub folder
                    paste("lat",lat,"lon",lon, sep = "_"),
                    paste("d_v_aet", model_bc_rcp, ".png", sep = "_"))) #file name)

# ------------
# D v. AET worst case
# ------------

ggplot(deficit_aet_wc, aes(x = deficit, y = aet)) +
  geom_point(aes(color = decades),
             size = 4,
             alpha = 0.6) +
  geom_encircle(aes(x = deficit, y = aet, color = decades),
                show.legend = FALSE,
                size = 2) +
  labs(title = wrap_sentence(paste("Deficit v. AET", model_wc, model_wc_rcp_name), 30),
       x = "Deficit",
       y = "AET")+
  scale_color_manual(breaks = c("1980-2019", "2020-2059", "2060-2099"),
                     values = c("#A3B86C", "#EBC944", "#1496BB")) +
  theme(legend.title = element_blank()) +
  ylim(NA, max_y_d_aet) +
  xlim(NA, max_x_d_aet) +
  theme(axis.title.x = element_text(size = 15))

ggsave(here::here("sites",
                   site, # site subfolder
                    "figures", #sub folder
                    paste("lat",lat,"lon",lon, sep = "_"),
                    paste("d_v_aet", model_wc_rcp, ".png", sep = "_"))) #file name)
  

```


## Soil Water

```{r, out.width="50%"}
plot_decades_smooth("soil_water_daily")
plot_annual("Soil Water")
plot_jitter("Soil Water")
```

## Runoff

```{r, out.width="50%"}
plot_decades_smooth("runoff_daily")
plot_annual("Runoff")
plot_jitter("Runoff")
```

## Rain

```{r, out.width="50%"}
plot_decades_smooth("rain_daily")
plot_annual("Rain")
plot_jitter("Rain")
```

## Accumulated Snow Water Equivalent (SWE)

```{r, out.width="50%"}
plot_decades_smooth("accumswe_daily")
plot_annual("Accumulated SWE")
plot_jitter("Accumulated SWE")
```

## Potential Evapotranspiration (PET)

```{r, out.width="50%"}
plot_decades_smooth("pet_daily")
plot_annual("PET")
```

## Actual Evapotranspiration (AET)

```{r, out.width="50%"}
plot_decades_smooth("aet_daily")
plot_annual("AET")
plot_jitter("AET")

```

## Deficit

```{r, out.width="50%"}
plot_decades_smooth("deficit_daily")
plot_annual("Deficit")
plot_jitter("Deficit")
```


```{r}
## Accumulated Growing Degree Days

# remove this title from the code chunk when AGDD is put back into the report.
```

```{r, out.width="50%"}
# plot_decades_line("agdd_daily") - fix later, this data is bad - shouldn't plot 8-20-20
#plot_annual("AGDD")

```


```{r}

#save this rmd as a file based on the site name in the site folder

```

## Works Cited

Stephenson, N. (1998). Actual evapotranspiration and deficit: biologically meaningful correlates of vegetation distribution across spatial scales. Journal of biogeography, 25(5), 855-870.
